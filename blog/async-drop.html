<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1"name=viewport><meta content="dark light"name=color-scheme><meta content=#ffffff name=theme-color media=(prefers-color-scheme:light)><meta content=#000000 name=theme-color media=(prefers-color-scheme:dark)><meta content="Sabrina Jewson"property=og:site_name><link href=/favicon.ico rel=icon><link href=/apple-touch-icon.png rel=apple-touch-icon><link href=/common.css rel=stylesheet><title>Async destructors, async genericity and completion futures - Sabrina Jewson</title><meta content="Async destructors, async genericity and completion futures"property=og:title><meta content="The main focus of this article will be on attempting to design a system to support asynchronous destructors in the Rust programming language, figuring the exact semantics of them and resolving any issues encountered along the way. By side effect, it also designs a language feature called “async genericity” which enables supporting blocking and asynchronous code with the same codebase, as well as designing a system for completion-guaranteed futures to be added to the language."name=description><meta content=article property=og:type><link href=post.css rel=stylesheet><link href=feed.xml rel=alternate title="Sabrina Jewson's Blog"type=application/atom+xml></head><body><header><a href=/ class=name>Sabrina Jewson</a><nav><a href=/blog/ >Blog</a></nav></header><main><h1>Async destructors, async genericity and completion futures</h1><p id=published><time datetime=2022-03-24>2022-03-24</time></p><nav><ul><li><a href=#why-async-destructors>Why async destructors?</a></li><li><a href=#async-drop-after-future-cancellation>Async drop after future cancellation</a></li><li><a href=#hidden-awaits>Hidden awaits</a><ul><li><a href=#abort-now>“Abort now” designs</a></li><li><a href=#never-abort>“Never abort” designs</a></li><li><a href=#delayed-abort>“Delayed abort” designs</a></li></ul></li><li><a href=#async-drop-in-a-sync-function>Async drop in a sync function</a></li><li><a href=#panic-checks>Panic checks</a></li><li><a href=#unwinding-in-async>Unwinding in async</a></li><li><a href=#poll-drop-ready><code class=scode>poll_drop_ready</code></a></li><li><a href=#function-implicit-bounds>Function implicit bounds</a></li><li><a href=#drop-supertrait>Drop supertrait</a></li><li><a href=#async-genericity>Async genericity</a></li><li><a href=#inspiration-from-const>Inspiration from <code class=scode>const</code></a></li><li><a href=#relaxed-drop-bounds>Relaxed drop bounds</a></li><li><a href=#synchronous-opt-out>Synchronous opt-out</a></li><li><a href=#async-traits-and-backwards-compatibility>Async traits and backwards compatibility</a></li><li><a href=#trait-impl-implicit-bounds>Trait impl implicit bounds</a></li><li><a href=#async-closures>Async closures</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#completion-futures>Appendix A: Completion futures</a></li><li><a href=#weakly-async-functions>Appendix B: Weakly async functions</a></li><li><a href=#linear-types>Appendix C: Linear types</a></li><li><a href=#uncancellable-futures>Appendix D: Uncancellable futures</a></li></ul></nav><p>The main focus of this article will be on attempting to design a system to support asynchronous destructors in the Rust programming language, figuring the exact semantics of them and resolving any issues encountered along the way. By side effect, it also designs a language feature called “async genericity” which enables supporting blocking and asynchronous code with the same codebase, as well as designing a system for completion-guaranteed futures to be added to the language.</p><h2 id=why-async-destructors><a href=#why-async-destructors class=anchor></a>Why async destructors?</h2><p>Async destructors, at a high level, would allow types to run code with <code class=scode>.await</code>s inside it when they are dropped. This enables cleanup code to actually perform I/O, giving much more freedom in the extent to which resources can be properly cleaned up. One notable use case for this is implementing the TLS protocol, in which:</p><blockquote><pre class=scode><code>Each party MUST send a "close_notify" alert before closing its write
side of the connection, unless it has already sent some error alert.
</code></pre></blockquote><p>(<a href=https://datatracker.ietf.org/doc/html/rfc8446#section-6.1>RFC 8446</a>). In order to make sure that this requirement is consistently fulfilled, TLS implementations should be able to send this alert when the <code class=scode>TlsStream</code> type is dropped - and if all I/O is done asynchronously, this requires asynchronous destructors.</p><p>Currently, this kind of cleanup is generally managed by methods like <a href=https://docs.rs/tokio/1/tokio/io/trait.AsyncWrite.html#tymethod.poll_shutdown><code class=scode>poll_shutdown</code></a> and <a href=https://docs.rs/futures-io/0.3/futures_io/trait.AsyncWrite.html#tymethod.poll_close><code class=scode>poll_close</code></a>: asynchronous functions that can optionally be called by the user if they want the type to be cleanly disposed of. However, this approach has several limitations:</p><ul><li>There is no way to statically guarantee that the method isn’t called twice, that’s up to the user.</li><li>There is no way to statically guarantee that the method is called at all - it can be very easy to forget.</li><li>Calling it at the lifecycle end of each value is cumbersome boilerplate, and would ideally not be necessary.</li><li>It only works on types that actually implement <code class=scode>AsyncWrite</code>. If your type is not actually a byte stream, too bad.</li></ul><p>Clearly we need a better solution than this. So let’s look at some practical examples to work out what features we’d need to improve the situation.</p><h2 id=async-drop-after-future-cancellation><a href=#async-drop-after-future-cancellation class=anchor></a>Async drop after future cancellation</h2><p>Let’s start simple, with this trivial function:</p><pre class=scode><code><span class="srust ssource">async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">wait_then_drop_stream</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">_stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta spath">time<span class="srust spunctuation saccessor">::</span></span>sleep<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta spath">Duration<span class="srust spunctuation saccessor">::</span></span>from_secs<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust sconstant snumeric sdecimal sinteger">10</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>It’s an asynchronous function that takes ownership of a <code class=scode>TlsStream</code>, sleeps for 10 seconds, then implicitly drops it at the end. The most obvious characteristic we want of this function is that the TLS stream should perform graceful <code class=scode>close_notify</code> shutdown after the 10 seconds. However there’s also a slightly more subtle but equally important one: because in Rust every future is implicitly made cancellable at <code class=scode>.await</code> points, the same graceful shutdown should also happen if the future is cancelled. For example, suppose the function is used like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">let</span> handle <span class="srust skeyword soperator">=</span> <span class="srust smeta spath">task<span class="srust spunctuation saccessor">::</span></span>spawn<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust sfunction ssupport">wait_then_drop_stream</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>some_tls_stream</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust smeta spath">time<span class="srust spunctuation saccessor">::</span></span>sleep<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta spath">Duration<span class="srust spunctuation saccessor">::</span></span>from_secs<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust sconstant snumeric sdecimal sinteger">5</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
handle.<span class="srust sfunction ssupport">cancel</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>Just because we cancel the task overall doesn’t mean we suddenly want to sidestep the regular graceful shutdown and have the TLS stream finish in an unclean manner - in fact, we almost never want that. So somehow we need a way to register async operations to occur after a future is cancelled, in order to support running the graceful shutdown code in there. How do we do that?</p><p>As it turns out, with async destructors in the language that becomes quite easy: since future cancellation is signalled to the future is via calling its destructor, the future can simply itself have an async destructor and run the cleanup code in there. The precise semantics of this would work in a very similar way to how synchronous destruction works today: drop each of the local variables in reverse order (and this critically includes the <code class=scode>_stream</code> variable).</p><h2 id=hidden-awaits><a href=#hidden-awaits class=anchor></a>Hidden awaits</h2><p>A second question we have to answer is what happens when async destruction <em>itself</em> is cancelled - for example, you might be in the middle of dropping a TLS stream, but at the same time your task suddenly gets aborted. To demonstrate this problem, take a look at this function:</p><pre class=scode><code><span class="srust ssource">async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">assign_stream</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">target</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> TlsStream, <span class="srust svariable sparameter">source</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust skeyword soperator">*</span>target <span class="srust skeyword soperator">=</span> source<span class="srust spunctuation sterminator">;</span> <span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Async destructor is implicitly called!
</span>	<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>1<span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
	async <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>2<span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>.await<span class="srust spunctuation sterminator">;</span>
	<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>3<span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
	<span class="srust sfunction ssupport">yield_now</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
	<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>4<span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>It assigns the <code class=scode>source</code> TLS stream to the <code class=scode>target</code> TLS stream (dropping the old <code class=scode>source</code> stream in the process), then prints out numbers 1 to 4. Under normal circumstances, this task would just run from top to bottom and always print out every number; but when cancellation gets involved, things become more complicated. If cancellation were to happen during the assignment of <code class=scode>source</code> to <code class=scode>target</code>, the language now has to decide what to do with the rest of the code - should it run it to the end? Should it immediately exit? Should it run only <em>some</em> of it?</p><p>There are three main categories of option worth talking about here: “abort now” designs, “never abort” designs and “delayed abort” designs. Each one has both advantages and drawbacks, which are explored in detail below.</p><h3 id=abort-now><a href=#abort-now class=anchor></a>“Abort now” designs</h3><p>Under these designs, none of the four prints in the code above are guaranteed to run - if the assignment is aborted, it will exit the future as soon as possible while performing the minimum amount of cleanup (i.e. just running destructors and nothing else).</p><p>There are three variants of this design, differing slightly in when they require <code class=scode>.await</code> to be specified:</p><ol><li><p>Sometimes await: Under this design, <code class=scode>=</code> is kept to never require an <code class=scode>.await</code> and async function calls are kept to always require an <code class=scode>.await</code>. This mostly keeps things the same way as they are: no special new syntax is introduced, and no major breaking changes are made.</p><p>To get a feel for how this looks, here is a non-trivial “real world” async function implemented using it:</p><pre class=scode><code><span class="srust ssource">async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">handle_stream</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Result<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust spunctuation ssection send sgroup">)</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust skeyword scontrol">loop</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust skeyword scontrol">match</span> <span class="srust sfunction ssupport">read_message</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> stream</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust skeyword soperator">?</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
			<span class="srust smeta spath">Message<span class="srust spunctuation saccessor">::</span></span>Redirect<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>address</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> <span class="srust skeyword soperator">=></span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
				stream <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">connect</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>address</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust skeyword soperator">?</span><span class="srust spunctuation sterminator">;</span>
				<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> The below line isn't guaranteed to run even if
</span>				<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> redirection succeded, since the future could be
</span>				<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> cancelled during the drop of the old `TlsStream`.
</span>				<span class="srust smeta spath">log<span class="srust spunctuation saccessor">::</span></span>info<span class="srust skeyword soperator">!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>Redirected<span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
			</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
			<span class="srust smeta spath">Message<span class="srust spunctuation saccessor">::</span></span>Exit <span class="srust skeyword soperator">=></span> <span class="srust skeyword scontrol">break</span><span class="srust spunctuation sseparator">,</span>
		</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>It does introduce a footgun as it will no longer be obvious at which points control flow can exit a function. It can also be considered inconsistent as some suspend points require an <code class=scode>.await</code> while others don’t, despite the fact that there is no meaningful semantic difference between the two kinds.</p></li><li><p>Never await: To resolve that inconsistency, this design removes <code class=scode>.await</code>s altogether, making all cancellation points completely invisible. Adapting our example from before, it would look like:</p><pre class=scode><code><span class="srust ssource">async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">handle_stream</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Result<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust spunctuation ssection send sgroup">)</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust skeyword scontrol">loop</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust skeyword scontrol">match</span> <span class="srust sfunction ssupport">read_message</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> stream</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust skeyword soperator">?</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
			<span class="srust smeta spath">Message<span class="srust spunctuation saccessor">::</span></span>Redirect<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>address</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> <span class="srust skeyword soperator">=></span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
				stream <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">connect</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>address</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust skeyword soperator">?</span><span class="srust spunctuation sterminator">;</span>
				<span class="srust smeta spath">log<span class="srust spunctuation saccessor">::</span></span>info<span class="srust skeyword soperator">!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>Redirected<span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
			</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
			<span class="srust smeta spath">Message<span class="srust spunctuation saccessor">::</span></span>Exit <span class="srust skeyword soperator">=></span> <span class="srust skeyword scontrol">break</span><span class="srust spunctuation sseparator">,</span>
		</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Aside from the technical issues of removing <code class=scode>.await</code> (is it done recursively? does it make implementing <code class=scode>Future</code> a breaking change? are async blocks made redundant? et cetera) and the backwards compatibility/churn issue, this has the same footgun issue as the previous option but turned up to the extreme - it would now be basically impossible to carefully manage where cancellations can occur and most users would end up having to treat cancellation more as a <code class=scode>pthread_kill</code> than a helpful control flow construct.</p></li><li><p>Always await: On the flip side, this design makes <code class=scode>.await</code>s mandatory everywhere. Assignments to a value with an asynchronous destructor must be done with a new <code class=scode>=.await</code> operator instead of plain <code class=scode>=</code>, and values cannot implicitly fall out of scope but must instead be explicitly <code class=scode>drop</code>ped by the user. Once again returning to the <code class=scode>handle_stream</code> example:</p><pre class=scode><code><span class="srust ssource">async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">handle_stream</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Result<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust spunctuation ssection send sgroup">)</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust skeyword scontrol">loop</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust skeyword scontrol">match</span> <span class="srust sfunction ssupport">read_message</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> stream</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust skeyword soperator">?</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
			<span class="srust smeta spath">Message<span class="srust spunctuation saccessor">::</span></span>Redirect<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>address</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> <span class="srust skeyword soperator">=></span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
				stream <span class="srust skeyword soperator">=</span>.await <span class="srust sfunction ssupport">connect</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>address</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust skeyword soperator">?</span><span class="srust spunctuation sterminator">;</span>
				<span class="srust smeta spath">log<span class="srust spunctuation saccessor">::</span></span>info<span class="srust skeyword soperator">!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>Redirected<span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
			</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
			<span class="srust smeta spath">Message<span class="srust spunctuation saccessor">::</span></span>Exit <span class="srust skeyword soperator">=></span> <span class="srust skeyword scontrol">break</span><span class="srust spunctuation sseparator">,</span>
		</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
	<span class="srust sfunction ssupport">drop</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>stream</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>This is the only option of the three to definitively avoid the “implicit cancel” footgun, but it’s still not ideal as it ends up introducing new weird-looking syntax and makes writing async code pretty verbose.</p></li></ol><p>All three of these variants end up with pretty significant drawbacks - fundamentally, it’s pretty incompatible with the current async syntax and model. So if aborting is so tricky to support, what if we could sidestep the problem by avoiding it altogether?</p><h3 id=never-abort><a href=#never-abort class=anchor></a>“Never abort” designs</h3><p>This design category eliminates implicit cancellation entirely from the language. Futures would, much like synchronous functions, run from linearly top to bottom without the possibility of caller-induced early exit (of course, panics can still cause early exit to happen). This means that all of <code class=scode>1</code>, <code class=scode>2</code>, <code class=scode>3</code> <em>and</em> <code class=scode>4</code> are guaranteed to be printed in the <code class=scode>assign_stream</code> function shown at the start of this section, since at no point is code execution ever allowed to stop. <a href=https://carllerche.netlify.app/2021/06/17/six-ways-to-make-async-rust-easier/ >This approach has been proposed by Carl Lerche previously</a>, if you want to read more about it.</p><p>Much like the “abort now” category, it has three sub-designs, “always await”, “sometimes await” and “never await” depending on where <code class=scode>.await</code> is deemed to be necessary. Much of the same arguments listed up there apply, although there is no longer the issue of the footgun caused by potential cancellation points being implicit so it is mostly a question of weighing up consistency, breakage and new syntax.</p><p>This is another highly consistent approach, however it comes with the major downside of throwing away the very useful tool that is implicit cancellation contexts. While it is definitely possible for cancellation to be implemented as a library feature (see <a href=https://docs.rs/tokio-util/0.7/tokio_util/sync/struct.CancellationToken.html><code class=scode>CancellationToken</code></a> and <a href=https://docs.rs/stop-token/0.7/stop_token/struct.StopToken.html><code class=scode>StopToken</code></a>) and I want that to be an option for use cases that need it, most of the time having an implicit context is far more useful since it is less verbose and requires much less boilerplate to make use of. I would hate to see otherwise infallible functions become fallible, or an enormous migration effort to add cancellation token parameters to every function.</p><p>One argument Carl Lerche used to support his point was an example code snippet in which future cancellation combined with <code class=scode>select!</code> turned out to be a footgun. But as Yoshua Wuyts argued in <a href=https://blog.yoshuawuyts.com/futures-concurrency-3/ >Futures Concurrency III</a>, the primary problem in code like that is the confusing semantics of <code class=scode>select!</code> and not the cancellation behaviour of futures. Ultimately, I do not believe cancellation to be problematic enough to warrant removing it from the language. Although this approach’s consistency and its parallel with blocking code is nice, cancellation is still useful and there are ways to combine it with async destructors that don’t introduce footguns.</p><p>Note that even with the other options, adding async destructors to the language would make it trivial to create a combinator that executes futures in a “no-cancellation” mode if such semantics are desired - see <a href=#uncancellable-futures>appendix D</a> for more.</p><h3 id=delayed-abort><a href=#delayed-abort class=anchor></a>“Delayed abort” designs</h3><p>Unlike the previous two designs, these approaches try to fully embrace the syntactical difference between assigning and falling out of scope, which don’t require an <code class=scode>.await</code>, and calling an async function, which does. When the caller attempts to cancel the future during one of the former operations, the future will actually continue to run for a short while afterwards until it is able to reach one of the latter operations and properly exit.</p><p>This immediately solves the main set of problems that plagued the “abort now” designs without going to the extreme that never-abort did: there is no footgun as cancellation points are never implicitly introduced, no new syntax is added and no major breaking changes are made, and there is now a definite reason <em>why</em> <code class=scode>=</code> doesn’t need <code class=scode>.await</code> but calling functions does.</p><p>However, it is not perfect. It effectively introduces two different kinds of suspend point which behave pretty differently, an inconsistency not present with “abort now” and “never abort” designs. Additionally, it means that if you call a wrapper function around the <code class=scode>=</code> operator or call <code class=scode>drop</code> manually, it has subtly different semantics from using the built-in language behaviour since it changes what kind of suspend point it is. This is probably unexpected and unintuitive for most users.</p><p>There are three variations of this design, depending on when the code stops running:</p><ol><li>Abort before first await: Code will continue to run after cancellation of an operation like <code class=scode>=</code> until the next point at which <code class=scode>.await</code> occurs, at which point the outer future will promptly exit without even polling the inner future once. In the <code class=scode>assign_stream</code> example, that means that <code class=scode>1</code> is guaranteed to be printed, but everything after that isn’t.</li><li>Abort after first await: As with the previous one, but the future will be polled once (only to have its result discarded and the outer future to exit). In our example, that means <code class=scode>1</code> and <code class=scode>2</code> are guranteed to be printed, but not anything beyond that.</li><li>Abort at first suspend: The outer future will abort the first time a future which it <code class=scode>.await</code>s returns <code class=scode>Poll::Pending</code> when it is polled. In the example code, this will force all of <code class=scode>1</code>, <code class=scode>2</code> and <code class=scode>3</code> to be printed, but not <code class=scode>4</code> since <code class=scode><span class="srust ssource"><span class="srust sfunction ssupport">yield_now</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span></code> causes a suspend point to occur. This is the most similar to how future cancellation works today, because cancellation cannot currently appear to happen without a suspend point (it still can’t with the above proposals, but it appears to because <code class=scode>async {}.await</code> potentially exits control flow). From the future’s perspective, this behaves is exactly as if the caller had just waited and then attempted cancellation later on.</li></ol><p>Although they might seem very similar, with the first two approaches an extremely subtle but very important paradigm shift is made: <code class=scode>.await</code> changes its meaning from being a “might suspend” operator to a “might halt” or “might abort” operator, since <code class=scode>async {}.await;</code> is now able to cause computation to suddenly stop. This is a small difference, but ends up very problematic as we now have to answer a whole host of new questions:</p><ul><li>If <code class=scode>.await</code> is just about cancellation, should we allow omitting it to call async functions while forbidding cancellation?</li><li>Should we allow calling <em>synchronous</em> functions with <code class=scode>.await</code> to introduce cancellation points around them?</li><li>Should we introduce plain <code class=scode>await;</code> statements to introduce those cancellation points, equivalent to <code class=scode>async {}.await;</code>?</li></ul><p>Phrased another way, we open ourselves up to this table existing whose empty boxes will come across as obvious holes:</p><table><thead><tr><th></th><th>Caller can’t cancel</th><th>Caller can cancel</th></tr></thead><tbody><tr><td><strong>Callee can’t cancel</strong></td><td><code class=scode>foo()</code></td><td>?</td></tr><tr><td><strong>Callee can cancel</strong></td><td>?</td><td><code class=scode>foo().await</code></td></tr></tbody></table><p>I don’t think that’s a situation we want to be in. The third approach avoids the whole situation altogether by tying abort opportunities to suspend points, removing the need for the second column in that table and thus closing those holes.</p><p>Additionally, the third variant is less of a breaking change because code that previously relied on the immediately-completing parts of an <code class=scode>async</code> operation not being able to abort won’t have to adjust their expectations. Technically it’s still non-breaking either way because no existing code uses asynchronous destructors, but it allows programmers to keep their mental model which is important too.</p><p>Because of all these reasons, I am in favour using a delayed abort design with abort-at-first-suspend: it would require little migration effort, avoids footguns and I don’t think is too surprising for users. The rest of this post will be written assuming that design is chosen.</p><h2 id=async-drop-in-a-sync-function><a href=#async-drop-in-a-sync-function class=anchor></a>Async drop in a sync function</h2><p>Perhaps the hardest problem any async drop design has to face is what happens when a type with an async destructor gets dropped in a synchronous context. Consider this code:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">sync_drop_stream</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">_stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>The synchronous function declared takes a TLS stream as a parameter. It must do something with the stream it has been given since it has ownership and there’s no return value to pass it back to the caller, but it can’t use a regular asynchronous drop because it is a synchronous function. So what can it do? In <a href=https://without.boats/blog/poll-drop/#the-non-async-drop-problem>withoutboats’ post on this subject</a> they hypothesized two options:</p><blockquote><ol><li>Call it’s non-async destructor, like every other type.</li><li>Introduce some kind of executor to the runtime (probably just <code class=scode>block_on</code>) to call as part of the drop glue.</li></ol></blockquote><p>To me, both solutions seem pretty bad. Solution 2 is obviously unworkable for the reasons Boats’ outlined, but I believe solution 1 is far more of a footgun than it appears. Many many functions from the standard library become essentially off-limits, so not only do you not get their ergonomics in well-written code it would be very easy to create bug-ridden code too, simply by calling any function like <a href=https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.insert><code class=scode>Option::insert</code></a> on a TLS stream.</p><p>My alternative solution is to forbid that code from compiling entirely. For a type to be dropped in a synchronous context it must implement a certain trait, and this just wouldn’t be implemented for <code class=scode>TlsStream</code> and similar types. Therefore, barring using of an explicit <code class=scode>close_unclean</code> method on <code class=scode>TlsStream</code>, it becomes totally impossible to cause an unclean TLS close from anywhere, eliminating an entire category of bugs.</p><p>This approach is not without its difficulties - in fact, it has more of them than the others and lots of this article will be simply dedicated to figuring them out. But ultimately, I do believe it to a better solution for the sake of those stronger static guarantees.</p><h2 id=panic-checks><a href=#panic-checks class=anchor></a>Panic checks</h2><p>I mentioned that this design would forbid at compile time async drop types being dropped in a synchronous context. So, seems easy right? Just detect when the compiler would run the destructor for each value and error out if it’s invalid.</p><pre class=scode><code><span class="srust ssource"><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Error
</span><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">bad</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{:?}</span><span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sseparator">,</span> stream.<span class="srust sfunction ssupport">protocol_version</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
	<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Implicitly dropped here: error!
</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> OK
</span><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">good</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> TlsStream</span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{:?}</span><span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sseparator">,</span> stream.<span class="srust sfunction ssupport">protocol_version</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
	stream
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Except…it’s not so simple. Because at nearly every point in a program, it is possible for the thread to panic, and if that happens unwinding might start to occur and if <em>that</em> happens you need to drop all the local variables in scope but you can only do that if they have a synchronous destructor! So really the compiler ought to forbid <em>any</em> usage of values with an asynchronous destructor in a synchronous context since panics can always happen and mess things up.</p><pre class=scode><code><span class="srust ssource"><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Error
</span><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">bad</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> TlsStream</span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> stream </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>But that doesn’t work either. The usage of types with an asynchronous destructor in a synchronous context is absolutely necessary in many circumstances, for example <code class=scode>TlsStream::close_unclean</code> which takes <code class=scode>self</code> or <code class=scode>block_on</code> which takes a future. What the compiler actually needs to enforce is then slightly more relaxed: While a value that cannot be synchronously dropped is held in scope, no operations that might panic can occur. “Operations that might panic” here includes calling any function or triggering any operator overload. It only doesn’t include simple things like constructing a struct or tuple, accessing a type’s field (without overloaded <code class=scode>Deref</code>), matching, returning, or any other built-in and trivial operation.</p><pre class=scode><code><span class="srust ssource"><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Error
</span><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">bad</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> TlsStream</span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{:?}</span><span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sseparator">,</span> stream.<span class="srust sfunction ssupport">protocol_version</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
	stream
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> OK
</span><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">good</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> TlsStream</span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> stream </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>This rule is quite limited, but actually provides all the tools necessary for dealing with this situation. It is particularly effective when combined with <code class=scode>ManuallyDrop</code>: because <code class=scode>ManuallyDrop</code> skips running the destructor of a type, it is always able to be synchronously dropped even if the type inside isn’t. So as long as the first might-panic operation you do upon obtaining one of these values is calling <code class=scode>ManuallyDrop::new</code> on it, the compiler will allow you to do anything you like since the burden has effectively been shifted to <em>you</em> to drop the value if you want. What’s more, <code class=scode>ManuallyDrop::new</code> itself doesn’t have to be implemented with any compiler magic - since all it does is execute a struct expression and return it, it passes the panic check just fine.</p><h2 id=unwinding-in-async><a href=#unwinding-in-async class=anchor></a>Unwinding in async</h2><p>Now that we’ve looked at what unwinding looks like in a synchronous context, let’s see what it looks like in an asynchronous one. It should be easier because this time we’re actually allowed to await on each value’s destruction.</p><pre class=scode><code><span class="srust ssource">async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">unwinds</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">_stream</span><span class="srust spunctuation sseparator">:</span> TlsStream</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust ssupport smacro">panic!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Sticking with the principle of forbidding ungraceful TLS stream shutdown entirely, it makes sense for the future to catch this panic and then asynchronously drop everything in scope like it usually would, before eventually propagating the panic to the caller.</p><p>For parity with synchronous code, while performing these asynchronous drops <a href=https://doc.rust-lang.org/stable/std/thread/fn.panicking.html><code class=scode>std::thread::panicking</code></a> would return <code class=scode>true</code> and similarly panicking again would result in an abort. Actually storing the in-flight panic in the future is easy: simply store an optional pointer that is the <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">Box<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>dyn Any <span class="srust skeyword soperator">+</span> Send<span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code> returned by <code class=scode>catch_unwind</code>, ready to be passed to <code class=scode>resume_unwind</code> later.</p><p>Unfortunately, those functions <a href=https://github.com/rust-lang/rfcs/issues/2810>aren’t available in <code class=scode>no_std</code> environments yet</a> so for now the compiler will probably have to use a workaround like aborting or leaking the values - or maybe implementing async destructors could be forbidden entirely on <code class=scode><span class="srust ssource"><span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#!</span><span class="srust spunctuation ssection sbegin sgroup">[</span><span class="srust svariable sannotation">no_std</span><span class="srust spunctuation ssection send sgroup">]</span></span></span></code>. If that issue is ever resolved it would be possible to improve the handling to something more useful.</p><p>There is one big issue with this approach however, and that is unwind safety. Unwind safety is the idea that panics in code can cause shared data structures to enter a logically invalid state, so whenever you are given the opportunity to observe the world after a panic it should be checked that you know that that might happen. This is regulated by two traits, <a href=https://doc.rust-lang.org/stable/std/panic/trait.UnwindSafe.html><code class=scode>UnwindSafe</code></a> and <a href=https://doc.rust-lang.org/stable/std/panic/trait.RefUnwindSafe.html><code class=scode>RefUnwindSafe</code></a>, which provide the necessary infrastructure to check all of this at compile time.</p><p>Implemented simply, this proposal would trivially break that concept:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sbegin sgroup">[</span><span class="srust svariable sannotation">derive</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">Clone<span class="srust spunctuation sseparator">,</span> Copy<span class="srust spunctuation sseparator">,</span> PartialEq<span class="srust spunctuation sseparator">,</span> Eq</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust spunctuation ssection send sgroup">]</span></span>
<span class="srust smeta senum"><span class="srust sstorage stype senum">enum</span> <span class="srust sentity sname senum">State</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> Valid<span class="srust spunctuation sseparator">,</span> Invalid </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust sstorage stype">let</span> state <span class="srust skeyword soperator">=</span> <span class="srust smeta spath">Cell<span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta spath">State<span class="srust spunctuation saccessor">::</span></span>Valid</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust sstorage stype">let</span> task <span class="srust skeyword soperator">=</span> <span class="srust ssupport smacro">pin!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>async <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sstorage stype">let</span> stream <span class="srust skeyword soperator">=</span> some_tls_stream<span class="srust spunctuation sterminator">;</span>
	state.<span class="srust sfunction ssupport">set</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta spath">State<span class="srust spunctuation saccessor">::</span></span>Invalid</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
	<span class="srust ssupport smacro">panic!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
	state.<span class="srust sfunction ssupport">set</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta spath">State<span class="srust spunctuation saccessor">::</span></span>Valid</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> <span class="srust skeyword soperator">_</span> <span class="srust skeyword soperator">=</span> task.<span class="srust sfunction ssupport">poll</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> cx</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Now the task is panicking and polling the TLS stream...
</span>
<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> But we can observe the invalid state!
</span><span class="srust ssupport smacro">assert_eq!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>state.<span class="srust sfunction ssupport">get</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sseparator">,</span> <span class="srust smeta spath">State<span class="srust spunctuation saccessor">::</span></span>Invalid</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>So what do we do? Well, we have a few options:</p><ol><li>Require that all local variables in async contexts are <code class=scode>UnwindSafe</code>. This would prevent the above code from compiling because <code class=scode>&Cell&lt;T></code> is <code class=scode>!UnwindSafe</code>.</li><li>Have compiler-generated <code class=scode>async {}</code> types only implement <code class=scode>Future</code> when <code class=scode>Self: UnwindSafe</code>. This is mostly the same as the first option, it just causes an error later in compilation.</li><li>Ignore unwind safety entirely - it’s already kind of useless because <code class=scode>std::thread::spawn</code> doesn’t require <code class=scode>F: UnwindSafe</code> and that can already be used to witness broken invariants. The system as a whole is definitely one of the more confusing and less understood parts of <code class=scode>std</code>, and it usually just amounts to slapping <code class=scode>AssertUnwindSafe</code> on everything until rustc is happy while not actually considering the implications.</li><li>Have async panics always cause synchronous drops of locals. This would force a sync drop option on types where it might not even make logical sense to have one, and async panic handling would permanently be done suboptimally.</li></ol><p>Personally, I’m quite in favour of option 3 - ignoring unwind safety entirely. I can’t think of a time where it has actually been useful for me or prevented a bug, but of course your mileage may vary (<a href=https://github.com/rust-lang/chalk/issues/260>I know <code class=scode>rust-analyzer</code> has been saved by unwind safety at least once</a>). I’m also open to option 1, although it could end up being quite a pain.</p><h2 id=poll-drop-ready><a href=#poll-drop-ready class=anchor></a><code class=scode>poll_drop_ready</code></h2><p>In the now-closed <a href=https://github.com/rust-lang/rfcs/pull/2958>RFC 2958</a>, withoutboats proposed the following design for implementing asynchronous destructors:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">Drop</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust spunctuation sterminator">;</span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">poll_drop_ready</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">cx</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgeneric">Context<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Poll<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust spunctuation ssection send sgroup">)</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust smeta spath">Poll<span class="srust spunctuation saccessor">::</span></span>Ready<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Under this design, dropping a type would be a simple matter of forwarding to <code class=scode>poll_drop_ready</code> inside the future’s <code class=scode>poll</code> function until it returns <code class=scode><span class="srust ssource"><span class="srust smeta spath">Poll<span class="srust spunctuation saccessor">::</span></span>Ready<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span></code> and execution can continue. Types would need to hold all state they need to use for destruction inside the type itself.</p><p>But this design comes with one <em>major</em> drawback that I haven’t seen mentioned so far: it breaks <code class=scode>Vec</code>’s three-pointer layout guarantee. The problem is that <code class=scode>Vec</code>, when destroyed, needs to drop each of its elements in order. So with an approach like <code class=scode>poll_drop_ready</code>, it would need to keep track of how many elements it has destroyed so far within the <code class=scode>Vec</code> itself, since it isn’t allowed to introduce any new external state during destruction. It can’t use any existing fields to do this - <code class=scode>ptr</code>, <code class=scode>len</code> and <code class=scode>capacity</code> are all necessary to keep around - therefore the only other option is adding a new field, but <a href=https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#guarantees>Rust already guarantees</a> that <code class=scode>Vec</code> will never do that.</p><p>It’s not like there aren’t potential solutions to this, like hardcoding <code class=scode>Vec</code>’s async drop code into the language or only making it four <code class=scode>usize</code>s for async-drop types. But both of those are a hack, and to me appear to just be working around a more fundamental problem with the design.</p><p>So how do we avoid this? Well, we have to allow types to hold state - <em>new</em> state - in their asynchronous destructors. Such a design was <a href=https://without.boats/blog/poll-drop/#the-destructor-state-problem>rejected by withoutboats</a> for two reasons:</p><ol><li>The resulting future can be unexpectedly <code class=scode>!Send</code>.</li><li>It doesn’t play well with trait objects.</li></ol><p>I don’t believe the first problem to be particularly bad, as if a type’s asynchronous destructor ends up being <code class=scode>!Send</code> that simply forms part of the type’s public API, similarly to how the type itself being <code class=scode>Send</code> is. And in generic contexts, since <code class=scode>Send</code> implementations leak all over the place anyway the <code class=scode>Send</code>ness of destructors can too: it would be up to the user to provide a type with a <code class=scode>Send</code> destructor if they want the resulting future to be <code class=scode>Send</code>.</p><p>Trait objects definitely pose a larger challenge - since the new state is of variable size, it’s not possible to stack-allocate it anywhere like we usually would with non-type-erased types. But this isn’t a problem that needs to be immediately solved: it’s possible to just forbid <code class=scode>dyn</code> trait objects with asynchronous destructors for now, and potentially fill in this gap later. Since users can always create user-space workarounds for this feature, it’s not urgent to attempt to stabilize a solution immediately. Additionally because it’s a problem shared with all async traits, not just async destructors, if a general solution is found for those it would end up working for this too.</p><h2 id=function-implicit-bounds><a href=#function-implicit-bounds class=anchor></a>Function implicit bounds</h2><p>Now we need to begin to consider how async drop works in generic code. In particular, when will a generic parameter enforce that a type does or does not support synchronous drop?</p><p>Within the current edition, it is essential that backward compatibility is maintained. Therefore, we can’t suddenly force <code class=scode>T: ?Drop</code> on any existing function or implementation, synchronous or asynchronous since they could very well be relying on synchronous drop support. If asynchronous drop is to be supported at all by an API, they must have to explicitly opt in to it (<a href=#relaxed-drop-bounds>more on this later</a>). All generic parameters and associated types without that opt-in would default to requiring a synchronous drop in every context.</p><p>To illustrate how this would work, here is an implementation of <code class=scode>FromIterator</code> for <code class=scode>Option</code> annotated with the implicit bounds:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>A, V<span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta simpl"> <span class="srust smeta sgeneric">FromIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>A<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">Option</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>V<span class="srust spunctuation send sdefinition sgeneric">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> A: Drop,
</span>	<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> V: Drop,
</span>	V<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">FromIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>A<span class="srust spunctuation send sdefinition sgeneric">></span></span>,
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">from_iter</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">iter</span><span class="srust spunctuation sseparator">:</span> I</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust sstorage stype">Self</span>
	</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		I<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">IntoIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Item = <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>A<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust spunctuation send sdefinition sgeneric">></span></span>,
		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> I: Drop,
</span>		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> No `I::IntoIter: Drop` bound is implied here since
</span>		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> that's provided by the IntoIterator trait already.
</span>	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		iter.<span class="srust sfunction ssupport">into_iter</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.<span class="srust sfunction ssupport">scan</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sseparator">,</span> <span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">|</span></span></span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters">_<span class="srust spunctuation sseparator">,</span> <span class="srust svariable sparameter">item</span><span class="srust spunctuation ssection send sparameters">|</span></span> </span><span class="srust smeta sfunction sclosure">item</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.<span class="srust sfunction ssupport">collect</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>As a side note, I’m using <code class=scode>T: Drop</code> syntax to mean “supports synchronous drop”. Unfortunately, that is counterintuitively <em>not</em> what <code class=scode>T: Drop</code> currently means, nor does it mean “the type <a href=https://doc.rust-lang.org/stable/std/mem/fn.needs_drop.html><code class=scode>needs_drop</code></a>”; instead, it is satisfied only if there a literal <code class=scode><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl"><span class="srust sentity sname simpl">Drop</span></span></span></code> block for the type, making the bound entirely useless in any actual code. But let’s ignore that and assume the more sensible meaning for now.</p><p>We get a lot more freedom when considering the next edition, and we can start relaxing the defaults of those bounds to something more commonly useful. As long as the standard library provides an adequate set of utilities for dealing with async drop types migrating should be painless.</p><p>Let’s look at a few simple examples to try and work out what these defaults should actually be.</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">sync_drops_a_value</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">v</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">sync_takes_a_ref</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">v</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span>T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">sync_drops_a_clone</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> Clone<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">v</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span>T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> v.<span class="srust sfunction ssupport">clone</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">async_drops_a_value</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">v</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p><code class=scode>sync_drops_a_value</code> and <code class=scode>sync_drops_a_clone</code> should probably compile as-is and not work with async drop types. Similarly, <code class=scode>async_drops_a_value</code> should obviously work with async drop types, because of course async destructors would be supported in an asynchronous context. At first glance it looks like <code class=scode>sync_takes_a_ref</code> can follow suit - after all, it’s not trying to drop anything - but in practicality it can’t, because the compiler shouldn’t have to look into its function body to determine whether it actually does something like <code class=scode>sync_drops_a_clone</code> does or not. While that situation is unfortunate, it is not all bad because as it turns out the extra restriction does not matter in most cases, since users can often add an extra reference to the type to bridge the gap.</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">takes_a_ref</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> implied to require not-async-drop <span class="srust spunctuation sdefinition scomment">*/</span></span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">val</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span>T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust sstorage stype">let</span> stream<span class="srust spunctuation sseparator">:</span> TlsStream <span class="srust skeyword soperator">=</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sfunction ssupport">takes_a_ref</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust skeyword soperator">&</span>stream</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span> <span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> doesn't work, since TlsStream is async-drop
</span><span class="srust sfunction ssupport">takes_a_ref</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust skeyword soperator">&</span>stream</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span> <span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> does work, since &TlsStream is not async-drop
</span></span></code></pre><p>Normally, a double reference functions totally equivalently to a single one, so this shouldn’t be a too big problem. And as older APIs gradually migrate to new syntax it becomes less and less of one.</p><p>So past the next edition all synchronous functions would implicitly bound each generic parameter by <code class=scode>T: Drop</code> and all asynchronous functions would use the async equivalent. While this doesn’t cover the desired behaviour 100% of the time, it covers the majority of cases and that’s all that’s needed for a default - explicit bounds can be used whereever necessary.</p><p>Inherent functions follow much the same idea. Consider this example:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">Wrapper</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span></span><span class="srust smeta sstruct"></span><span class="srust smeta sstruct"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>T</span><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">Wrapper</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">some_sync_method</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">ref_method</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
	async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">some_async_method</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>With all the implicit bounds made explicit, it would look like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">Wrapper</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span></span><span class="srust smeta sstruct"></span><span class="srust smeta sstruct"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>T</span><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">Wrapper</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">some_sync_method</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span> T<span class="srust spunctuation sseparator">:</span> Drop </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">ref_method</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span> T<span class="srust spunctuation sseparator">:</span> Drop </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
	async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">some_async_method</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span> T<span class="srust spunctuation sseparator">:</span> AsyncDrop </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>There is one small addition though: because of the frequency of wanting to define several synchronous methods that don’t care about drop, one can specify relaxed bounds on the <code class=scode><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span></span></code> block itself and have it apply to every function inside of it. This would be useful for defining many of the <code class=scode>Option</code> methods:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust sillegal sinvalid">?</span></span></span><span class="srust smeta simpl"><span class="srust sentity sname simpl">Drop</span>> <span class="srust sentity sname simpl">Option</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage smodifier">pub</span> <span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">is_some</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust sstorage stype">bool</span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage smodifier">pub</span> <span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">is_none</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust sstorage stype">bool</span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage smodifier">pub</span> <span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">as_ref</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">&</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage smodifier">pub</span> <span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">as_mut</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
	<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> et cetera
</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>The choices of the exact syntax for this is discussed more later.</p><h2 id=drop-supertrait><a href=#drop-supertrait class=anchor></a>Drop supertrait</h2><p>The following code compiles today:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">Foo</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">consumes_self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>If any declared trait didn’t imply <code class=scode>Drop</code> as a supertrait, then we would have a breaking change as there would no longer be a guarantee that <code class=scode>self</code> can be dropped like that. Ultimately, I would like to follow in the path of <code class=scode>Sized</code> and have <code class=scode>Foo: Drop</code> <em>never</em> implied so that the above code would need an explicit <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span> <span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust ssupport stype">Drop</span></span></code> bound, but until then that code must desugar like so:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">Foo</span>: Drop <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">consumes_self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>And everything can compile again.</p><p>It’s also possible that we could introduce some more complex rules about this in the current edition, like “the supertrait is only implied if there are any default methods”; but they would only help in a small number of cases and it would be easier to just convince users to use the next edition.</p><h2 id=async-genericity><a href=#async-genericity class=anchor></a>Async genericity</h2><p>With the current suggestions taken alone, although async drop will be supported it would be rather inconvenient since almost no existing standard library APIs would support it. Just to show how difficult it would be to use, here are some functions that wouldn’t work with async drop types:</p><ul><li><code class=scode>Option::insert</code>, since it can drop the old value in the <code class=scode>Option</code>.</li><li>Many <code class=scode>HashMap</code> functions: <code class=scode>insert</code>, <code class=scode>entry</code>, etc since they call methods of user-supplied generics which can always panic.</li><li><code class=scode>Vec::push</code>, since it’s synchronous and can panic if the <code class=scode>Vec</code>’s length exceeds <code class=scode>isize::MAX</code>.</li><li><code class=scode>Box::new</code>, since it’s possible that allocation will be allowed to panic.</li></ul><p>One potential option is to introduce <code class=scode>_async</code> variants of each of these functions that are <code class=scode><span class="srust ssource">async <span class="srust sfunction sstorage stype">fn</span></span></code>s. When dealing with async-drop types, you’d call <code class=scode><span class="srust ssource">vec.<span class="srust sfunction ssupport">push_async</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>item</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span></span></code> instead of <code class=scode><span class="srust ssource">vec.<span class="srust sfunction ssupport">push</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>item</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span></span></code> and <code class=scode><span class="srust ssource"><span class="srust ssupport stype">Box</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>new_async<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>value</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await</span></code> instead of <code class=scode><span class="srust ssource"><span class="srust ssupport stype">Box</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>value</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span></code>. However this would nearly double the API surface of the standard library and lead to a large amount of code duplication. This is obviously undesirable, so what can we do about it?</p><p>One potential path forward is a feature known as async overloading, <a href=https://blog.yoshuawuyts.com/async-overloading/ >previously proposed by Yoshua Wuyts</a>. The idea is that synchronous functions can be overloaded by asynchronous ones, allowing <code class=scode>Vec::push_async</code> and <code class=scode>Vec::push</code> to effectively share the same namespace, and have the correct function be chosen based on context.</p><p>While this does solve the first problem of the doubled API surface quite neatly, it does not however solve the second problem of code duplication - one would still have to write two copies of nearly-identical code for an async and sync implementation of the same algorithm. And it comes with its own problems too, such as needing a good way to force one particular overload to be chosen of multiple possibilities.</p><p>My alternative idea is what I will refer to as async genericity. Unlike async overloading which has two separate functions with different bodies, under async genericity the async and sync equivalents of one function share a body that works for both. The compiler can then monomorphize this into two separate functions, just like it does for generic parameters. The correct version will be chosen at call site depending on the traits the given generic parameters implement. It is, to some extent, colourless async.</p><h2 id=inspiration-from-const><a href=#inspiration-from-const class=anchor></a>Inspiration from <code class=scode>const</code></h2><p>I’d like to take inspiration from <a href=https://github.com/rust-lang/rust/issues/67792>the work on <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span> <span class="srust sfunction sstorage stype">fn</span></span></code></a> which faces a similar problem to the one we’re facing now: how can one function be written that works for multiple modes (async/sync, const/non const)? A simple example of that is <code class=scode>drop</code>:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">const</span> <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust sillegal sinvalid">~</span></span><span class="srust sstorage stype">const</span> <span class="srust ssupport stype">Drop</span><span class="srust skeyword soperator">></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>_x<span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span></code></pre><p>This function can be treated as “expanding” into two separate functions:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">const</span> <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop_const</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> const Drop<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">_x</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop_non_const</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">_x</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Where the correct one will be chosen at call site depending on whether <code class=scode>T</code> can be dropped in <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span></span></code> contexts. <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span> <span class="srust ssupport stype">Drop</span></span></code> is a compiler-generated <code class=scode>Drop</code> subtrait which has all the same methods as <code class=scode>Drop</code>, but converted to <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span> <span class="srust sfunction sstorage stype">fn</span></span></code>s. This <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span></span></code> modifier can actually be applied to any trait to automatically make it <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span></span></code>: <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span> <span class="srust ssupport stype">Iterator</span></span></code>, <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span> Add</span></code> et cetera. You can read more about this in <a href=https://internals.rust-lang.org/t/pre-rfc-revamped-const-trait-impl-aka-rfc-2632/15192>its pre-RFC</a>, I won’t go into the details here.</p><p>I will use this as a starting point for the async generics design. It might look something like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">_x</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>The <code class=scode>T: ~async Drop</code> bound is implied, like how <code class=scode>T: async Drop</code> would be implied in normal <code class=scode><span class="srust ssource">async <span class="srust sfunction sstorage stype">fn</span></span></code>s. It “expands” to:</p><pre class=scode><code><span class="srust ssource">async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop_async</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">_x</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop_sync</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">_x</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>In cases where there are multiple generic parameters, like for example:</p><pre class=scode><code><span class="srust ssource"><span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop_pair</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>A, B<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">_</span>: A, <span class="srust skeyword soperator">_</span>: B</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>The synchronous version is only possible when <em>all</em> parameters implement the synchronous version of the trait.</p><pre class=scode><code><span class="srust ssource"><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> `A: async Drop, B: async Drop`
</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop_pair_async</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>A, B<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">_</span>: A, <span class="srust skeyword soperator">_</span>: B</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> `A: Drop, B: Drop`
</span><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop_pair_sync</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>A, B<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">_</span>: A, <span class="srust skeyword soperator">_</span>: B</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>If the function is being called where <code class=scode>A: Drop</code> but <code class=scode>B: async Drop</code>, the async version will be selected since <code class=scode>A: Drop</code> implies <code class=scode>A: async Drop</code> already.</p><p>If an <code class=scode>~async fn</code> is declared with <em>no</em> generic parameters that have an <code class=scode>~async</code> bound, then it’s actually totally equivalent to a synchronous function and should probably be warned against by rustc.</p><p>One important aspect to note is that <code class=scode><span class="srust ssource">async</span></code> is somewhat the opposite of <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span></span></code>. While a non-<code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span></span></code> function can always be substituted for a <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span></span></code> one, the inverse is true of <code class=scode>async</code>: an <code class=scode><span class="srust ssource">async</span></code> function can always be substituted for a sync one but not the other way around. This means that while <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span> Trait</span></code> is a subtrait of <code class=scode>Trait</code> (fewer types implement it than just <code class=scode>Trait</code>), <code class=scode><span class="srust ssource">async Trait</span></code> is a supertrait of <code class=scode>Trait</code> (more types implement it than just <code class=scode>Trait</code>). Or in other words, <code class=scode><span class="srust ssource"><span class="srust sstorage stype">const</span> Trait<span class="srust spunctuation sseparator">:</span> Trait<span class="srust spunctuation sseparator">:</span> async Trait</span></code>.</p><p>Another important impact of this system is that, unlike with <code class=scode>const</code>, upgrading an implementation from <code class=scode>async Trait</code> to <code class=scode>Trait</code> is a breaking change since the methods will now by default be synchronous instead of asynchronous, so you’ll get errors whereever you previously were using <code class=scode>.await</code>. Of course, the actual number of use cases is universally increased, not reduced (passing it to a function that accepts <code class=scode>async Trait</code> still works, and the methods will still require <code class=scode>.await</code> there) but direct callers will need to modify their code to have it build. However this should not be a large problem since it’s generally well known up front whether something will need async or not.</p><p>Another option would be to have <code class=scode>async Trait</code> and <code class=scode>Trait</code> be treated as two entirely separate traits, with no inherent connection between the two. This has the advantage of preventing mistakes like using <code class=scode>std::fs::File</code> in an asynchronous function at compile time (since <code class=scode>std::fs::File</code> would <em>not</em> implement <code class=scode>async Read</code>), but overall I do not think that to be worth it:</p><ol><li><p>Users can end up making the mistake anyway, just by calling a concrete blocking function like <code class=scode><span class="srust ssource">.<span class="srust sfunction ssupport">metadata</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span></code> on a <code class=scode>Path</code> or <code class=scode><span class="srust ssource"><span class="srust smeta spath">std<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta spath">thread<span class="srust spunctuation saccessor">::</span></span>sleep</span></code>. It would only help prevent a small number of cases.</p></li><li><p>It is not always a mistake; sometimes it <em>is</em> useful to run blocking code in an asynchronous context, if for example one wants to mix asynchronous and blocking function calls on a blocking worker thread.</p></li><li><p>Sometimes whether an operation will <em>actually</em> block is only known dynamically, for example reading from a TCP stream - if it the stream is in <a href=https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.set_nonblocking>non-blocking mode</a> (which is explicitly a supported use case by the standard library) it should be fine to call it from <code class=scode>async</code> code.</p></li><li><p>By default types like <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">Vec<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">u8</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code> (whose <code class=scode>Write</code> implementation is neither asynchronous nor blocking, and thus can be used in both contexts) would end up being exclusively synchronous. To support both, it would have to write out boilerplate code to implement both <code class=scode>async Trait</code> and <code class=scode>Trait</code> separately, or we’d have to introduce <em>another</em> new piece of syntax to share an implementation.</p><p>It gets worse when considering <code class=scode>Drop</code> - every non-generic type implementing that trait would have to migrate to this new syntax to even be usable at all in asynchronous contexts (or we could special-case <code class=scode>Drop</code> to have shared implementations, but I can’t think of a strong reason why <code class=scode>Drop</code> should be treated so differently from everything else).</p></li><li><p>Having the traits be separate rather increases the complexity of the system overall.</p></li></ol><h2 id=relaxed-drop-bounds><a href=#relaxed-drop-bounds class=anchor></a>Relaxed drop bounds</h2><p>We introduced implicit default <code class=scode>Drop</code> bounds in a <a href=#function-implicit-bounds>previous section</a>; now that we have some actual syntax for async drop (<code class=scode>async Drop</code>) the question is how those bounds can be relaxed for functions that allow it.</p><p>I’d first like to introduce a new concept in this section: the <code class=scode>?Drop</code> bound. This bound can be considered the initial one before implicit bounds are added, and it imposes absolutely no requirements on to what extent the type supports being dropped. There would not be any situation in which this bound is necessary over <code class=scode>async Drop</code>, since the least “droppable” a type can be is <code class=scode>async Drop</code> - applying it only takes abilities away from the implementor while giving none to the caller. But it is still important to have because it avoids panic-check-passing synchronous functions that don’t care at all about <code class=scode>async</code> (<code class=scode>mem::replace</code>, <code class=scode>any::type_name</code>, <code class=scode>Option::map</code> etc) from having to write <code class=scode>async</code> in their signature to be general. It would feel rather strange for them to declare <code class=scode>&lt;T: async Drop></code> or something when they actually don’t drop the type asynchronously at all. It also enables future extensions into more kinds of drop which <a href=#linear-types>may be useful</a>.</p><p>All functions have a stronger default bound for generic parameters than <code class=scode>?Drop</code>, and that can be relaxed to <code class=scode>?Drop</code> in much the same way as the other implied bound in Rust, <code class=scode>Sized</code>: by adding <code class=scode>?Drop</code> as a trait bound in the parameter list or in the where clause. Like with <code class=scode>Sized</code> it only accepts the simple cases, so <code class=scode>?Drop</code> cannot be used as a supertrait (it is <a href=#drop-supertrait>the default anyway</a>) or as a bound on types other than a literal type parameter. There is a slight inconsistency here in that <code class=scode>?Drop</code> is used even when the implied bound isn’t actually <code class=scode>Drop</code>, because it could be in reality <code class=scode>async Drop</code>; so in a way it should really be <code class=scode>?async Drop</code> if the outer function is <code class=scode><span class="srust ssource">async</span></code> and only <code class=scode>?Drop</code> if the outer function is sync. But since <code class=scode>?Drop</code> is shorter, more consistent and unambiguous anyway there’s no strong reason not to use it.</p><p>When relaxing bounds to something weaker than the default but stronger than <code class=scode>?Drop</code>, (particularly, setting them to <code class=scode>async Drop</code> in a synchronous function) the most obvious option is to support the trait name directly - use <code class=scode>T: async Drop</code> to support <code class=scode>T</code> not implementing any of the <code class=scode>Drop</code> subtraits (<code class=scode>Drop</code>, <code class=scode>const Drop</code>), but requiring it to implement <code class=scode>async Drop</code>. However this approach ends up being quite problematic because unlike <code class=scode>?Drop</code> whose unique syntax excuses it from only supporting a few special cases, <code class=scode>async Drop</code> is also a trait like any other and so must be supported in the general case like any other.</p><p>What this means is that having <code class=scode>T: async Drop</code> implicitly also relax a <code class=scode>Drop</code> bound breaks down in more complex cases (such as when it’s implied through a supertrait, or transitively via a bound in the <code class=scode>where</code> clause applied to another type) leading to inconsistent behaviour and confusing semantics.</p><p>Instead, Rust should take the consistent approach of <em>allowing</em> (but potentially warning against) bounds like <code class=scode>T: async Drop</code> on a synchronous function, but not giving them any effect unless they’re <em>also</em> paired with <code class=scode>?Drop</code>. Since <code class=scode>Drop</code> implies <code class=scode>async Drop</code>, adding <code class=scode>async Drop</code> in a synchronous function is a tautology and only by taking away the initial <code class=scode>Drop</code> bound does it have a meaning.</p><p>The only problem with this approach is its verbosity: <code class=scode>T: ?Drop + async Drop</code> is quite the mouthful to express one concept. It’s possible that Rust could introduce some syntax sugar to make it shorter, the only difficulty is what the actual syntax of that would be while remaining clear and unambiguous. I’m very much open to suggestions here.</p><h2 id=synchronous-opt-out><a href=#synchronous-opt-out class=anchor></a>Synchronous opt-out</h2><p>While blindly turning every method in the trait <code class=scode>const</code> works most of the time for <code class=scode>const Trait</code>s, it doesn’t end up working so well for <code class=scode>async Trait</code>s. In particular, there are quite a few methods that would benefit from always being synchronous whether the outer trait is considered asynchronous or not, for example:</p><ul><li><code class=scode>Iterator::size_hint</code> and <code class=scode>ExactSizeIterator::len</code>: These methods should be O(1) and not perform I/O, so there’s no reason to have them be <code class=scode>async</code>.</li><li><code class=scode>Iterator::{step_by, chain, zip, map, filter, enumerate, ...}</code>: These functions just construct a type and return it, no asynchronity here.</li><li><code class=scode>Read::{by_ref, bytes, chain, take}</code>: More trivial functions that just construct a type.</li><li><code class=scode>BufRead::consume</code>: Any I/O done by the <code class=scode>BufRead</code> should occur in <code class=scode>fill_buf</code> and all <code class=scode>consume</code> should do is move around a couple numbers. Hence, it should be always synchronous.</li></ul><p>So evidently trait definitions need to be able to control what their <code class=scode>async</code> form would look like. Having any kind of default chosen by the Rust compiler would be a bad idea, because even without thinking about <code class=scode>async</code> code, just by writing a single trait you’d have already chosen and stabilized an <code class=scode>async</code> API. Plus, it’s not like many traits need to have async equivalents - it’s mostly just <code class=scode>Iterator</code>, I/O traits, functions and <code class=scode>Drop</code> that matter. Therefore I think it is best to have <code class=scode>async Trait</code> support be an opt-in by the trait declarer.</p><p>The syntax to declare one of these traits can be something along the lines of <code class=scode>trait ~async Foo</code>, <code class=scode>~async trait Foo</code>, or <code class=scode>async trait Foo</code> - I don’t have a strong preference and will use the first for now. In order to declare the methods of these traits as being conditionally async, the same <code class=scode>~async</code> syntax can actually be borrowed over from generic async functions - <code class=scode>Self</code> will just be treated as another generic parameter with an <code class=scode>~async Trait</code> bound. This produces a nice parallel between functions and traits, as demonstrated below:</p><pre class=scode><code><span class="srust ssource"><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> What you write
</span><span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust sillegal sinvalid">~</span></span>async Trait<span class="srust skeyword soperator">></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>

<span class="srust sstorage stype strait">trait</span> <span class="srust skeyword soperator">~</span>async Trait <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust spunctuation sterminator">;</span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> What it "expands" to
</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f_async</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> async Trait<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f_sync</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> Trait<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta strait"><span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">async</span> Trait <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust spunctuation sterminator">;</span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust smeta strait"><span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">Trait</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust spunctuation sterminator">;</span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>And since those functions are actually just regular <code class=scode>~async</code> functions, they also interact with generic parameters:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype strait">trait</span> <span class="srust skeyword soperator">~</span>async Trait <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust sillegal sinvalid">~</span></span>async Read<span class="srust skeyword soperator">></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>val<span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> What it "expands" to
</span><span class="srust smeta strait"><span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">async</span> Trait <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f_async</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> async Read<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">val</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust smeta strait"><span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">Trait</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f_async</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> async Read<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">val</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust spunctuation sterminator">;</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f_sync</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> Read<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">val</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> A synchronous implementation
</span><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl">Trait <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> () </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust sillegal sinvalid">~</span></span>async Read<span class="srust skeyword soperator">></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>val<span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> An asynchronous implementation
</span><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl"><span class="srust sentity sname simpl">async</span> <span class="srust sentity sname simpl">Trait</span> <span class="srust sentity sname simpl">for</span> <span class="srust sentity sname simpl">u32</span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> async Read<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">val</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> A generic implementation
</span><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust sillegal sinvalid">~</span></span></span><span class="srust smeta simpl"><span class="srust sentity sname simpl">async</span> <span class="srust sentity sname simpl">Trait</span>> ~<span class="srust sentity sname simpl">async</span> <span class="srust sentity sname simpl">Trait</span> <span class="srust sentity sname simpl">for</span> <span class="srust skeyword soperator">&</span><span class="srust sentity sname simpl">T</span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">f</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust sillegal sinvalid">~</span></span>async Read<span class="srust skeyword soperator">></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>val<span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Just like with regular <code class=scode>~async</code> functions, the synchronous version only exists when <em>all</em> generic parameters (here, both <code class=scode>T</code> and <code class=scode>Self</code>) implement the trait synchronously.</p><p>The last thing to note is that associated types in <code class=scode>~async Trait</code>s would have the implicit bound <code class=scode>~async Drop</code>: when the trait is an <code class=scode>async Trait</code> they’re allowed to be <code class=scode>async Drop</code> but when it’s a synchronous <code class=scode>Trait</code> they are required to be <code class=scode>Drop</code>. This should follow the rules that users will want most of the time.</p><p>To conclude, I’ll leave you with an annotated snippet of how the <code class=scode>Iterator</code> trait might look with added <code class=scode>async</code> support:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust skeyword soperator">~</span>async <span class="srust ssupport stype">Iterator</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust sentity sname stype">Item</span><span class="srust spunctuation sterminator">;</span>

	<span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation send sdefinition sgeneric">></span></span></span></span><span class="srust spunctuation sterminator">;</span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">size_hint</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust sstorage stype">usize</span>, <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">usize</span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust spunctuation ssection send sgroup">)</span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust sconstant snumeric sdecimal sinteger">0</span><span class="srust spunctuation sseparator">,</span> <span class="srust ssupport stype">None</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

	<span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">fold</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>B, F<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">init</span><span class="srust spunctuation sseparator">:</span> B, <span class="srust svariable sparameter">f</span><span class="srust spunctuation sseparator">:</span> F</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> B
	</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		<span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> Sized,
		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> `fold` always drops `Self` at the end so this bound is required.
</span>		<span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> ~async Drop,
		F<span class="srust spunctuation sseparator">:</span> ~async FnMut<span class="srust spunctuation ssection sbegin sgroup">(</span>B, <span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation ssection send sgroup">)</span> -> B,
		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> We can't relax B's bound because it's dropped in the event that
</span>		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> `self.next()` panics.
</span>	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> accum <span class="srust skeyword soperator">=</span> init<span class="srust spunctuation sterminator">;</span>
		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> `.await` is required in both cases because it could be a cancellation
</span>		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> point.
</span>		<span class="srust skeyword scontrol">while</span> <span class="srust sstorage stype">let</span> <span class="srust ssupport stype">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>x</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> <span class="srust skeyword soperator">=</span> <span class="srust svariable slanguage">self</span>.<span class="srust sfunction ssupport">next</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
			accum <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">f</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>accum<span class="srust spunctuation sseparator">,</span> x</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
		</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
		accum
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">map</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>B, F<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">f</span><span class="srust spunctuation sseparator">:</span> F</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Map<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">Self</span>, F<span class="srust spunctuation send sdefinition sgeneric">></span></span>
	</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		<span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> Sized,
		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Even a synchronous iterator's `map` accepts an `async FnMut` here,
</span>		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> without the tilde. This is because every `FnMut` is also an
</span>		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> `async FnMut`, so `async FnMut` is the strictly more general bound.
</span>		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> The tilde is only necessary when the function effectively needs to
</span>		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> specialize on the synchronous case to not be async, but that's not
</span>		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> necessary here since `map` isn't ever async anyway.
</span>		F<span class="srust spunctuation sseparator">:</span> async FnMut<span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation ssection send sgroup">)</span> -> B,
		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> The default bounds are overly restrictive, so we relax them.
</span>		F<span class="srust spunctuation sseparator">:</span> ?Drop,
		B<span class="srust spunctuation sseparator">:</span> ?Drop,
	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust smeta spath">Map<span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust svariable slanguage">self</span><span class="srust spunctuation sseparator">,</span> f</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

	<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> et cetera
</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span></code></pre><p>Compared to the current design of adding a new <code class=scode>Stream</code>/<code class=scode>AsyncIterator</code> trait, this has the following advantages:</p><ul><li>We don’t have to decide between async vs sync callbacks for functions like <code class=scode>fold</code> (currently <a href=https://docs.rs/futures-util/0.3/futures_util/stream/trait.StreamExt.html#method.fold>futures-util</a> and <a href=https://docs.rs/tokio-stream/0.1/tokio_stream/trait.StreamExt.html#method.fold>tokio-stream</a> disagree about this).</li><li>We don’t have two separate functions <code class=scode>.map</code> and <code class=scode>.then</code> for sync and async respectively.</li><li><code class=scode>.map</code> with an async function can be called on a synchronous iterator, automatically turning it into an async one.</li><li>There’s no need for additional conversion functions like <code class=scode>.into_stream()</code> or <code class=scode>.into_async_iter()</code>.</li><li>Existing iterators like <code class=scode>slice::Iter</code> will automatically implement the new <code class=scode>async Iterator</code> trait.</li></ul><h2 id=async-traits-and-backwards-compatibility><a href=#async-traits-and-backwards-compatibility class=anchor></a>Async traits and backwards compatibility</h2><p>If you look closely at my definition of <code class=scode>Iterator</code> above you’ll notice that it’s actually not backward compatible with the current definition of <code class=scode>Iterator</code>. The problem is that today, people can override functions like <code class=scode>fold</code> that are less powerful than the <code class=scode>~async</code> version. For example:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl">Iterator <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">Example</span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust sentity sname stype">Item</span> <span class="srust skeyword soperator">=</span> <span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation send sdefinition sgeneric">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust ssupport stype">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">fold</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>B, F<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span>, <span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">accum</span><span class="srust spunctuation sseparator">:</span> B, <span class="srust svariable sparameter">f</span><span class="srust spunctuation sseparator">:</span> F</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> B
	</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		F<span class="srust spunctuation sseparator">:</span> FnMut<span class="srust spunctuation ssection sbegin sgroup">(</span>B, <span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation ssection send sgroup">)</span> -> B,
	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust skeyword scontrol">loop</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> accum <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">f</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>accum<span class="srust spunctuation sseparator">,</span> <span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Under my definition of <code class=scode>Iterator</code>, that code would instead need to be rewritten like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl">Iterator <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">Example</span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust sentity sname stype">Item</span> <span class="srust skeyword soperator">=</span> <span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation send sdefinition sgeneric">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust ssupport stype">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

	<span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">fold</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>B, F<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span>, <span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">accum</span><span class="srust spunctuation sseparator">:</span> B, <span class="srust svariable sparameter">f</span><span class="srust spunctuation sseparator">:</span> F</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> B
	</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		F<span class="srust spunctuation sseparator">:</span> ~async FnMut<span class="srust spunctuation ssection sbegin sgroup">(</span>B, <span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation ssection send sgroup">)</span> -> B,
	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust skeyword scontrol">loop</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> accum <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">f</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>accum<span class="srust spunctuation sseparator">,</span> <span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>The iterator itself is still not async, but this change would additionally allow calling <code class=scode>fold</code> with an asynchronous callback even if the underlying iterator is still synchronous.</p><p>Unfortunately, we can’t just make the first version stop compiling due to Rust’s backward compatibility guarantees. And even an edition won’t be able to fix this, since the issue is greater than just a syntactical one.</p><p>I don’t think there is a reasonable way to somehow fix <code class=scode>fold</code> itself - its signature is effectively set in stone at this point. But we <em>can</em> add a <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span> <span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Iterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Item = <span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code> bound to it and then have the generic version be under a new name, <code class=scode>fold_async</code>. Since <code class=scode>fold_async</code> would be strictly more general than <code class=scode>fold</code>, the default implementation of <code class=scode>fold</code> can just forward to it. So the definition of <code class=scode>Iterator</code> would actually look more like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust skeyword soperator">~</span>async <span class="srust ssupport stype">Iterator</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust sentity sname stype">Item</span><span class="srust spunctuation sterminator">;</span>

	<span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation send sdefinition sgeneric">></span></span></span></span><span class="srust spunctuation sterminator">;</span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">fold</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>B, F<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">init</span><span class="srust spunctuation sseparator">:</span> B, <span class="srust svariable sparameter">f</span><span class="srust spunctuation sseparator">:</span> F</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> B
	</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		<span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Iterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Item = <span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation send sdefinition sgeneric">></span></span> + Sized + Drop,
		F<span class="srust spunctuation sseparator">:</span> FnMut<span class="srust spunctuation ssection sbegin sgroup">(</span>B, <span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation ssection send sgroup">)</span> -> B,
	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust svariable slanguage">self</span>.<span class="srust sfunction ssupport">fold_async</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>init<span class="srust spunctuation sseparator">,</span> f</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

	<span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">fold_async</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>B, F<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">init</span><span class="srust spunctuation sseparator">:</span> B, <span class="srust svariable sparameter">f</span><span class="srust spunctuation sseparator">:</span> F</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> B
	</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		<span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> Sized + ~async Drop,
		F<span class="srust spunctuation sseparator">:</span> ~async FnMut<span class="srust spunctuation ssection sbegin sgroup">(</span>B, <span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item<span class="srust spunctuation ssection send sgroup">)</span> -> B,
	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> accum <span class="srust skeyword soperator">=</span> init<span class="srust spunctuation sterminator">;</span>
		<span class="srust skeyword scontrol">while</span> <span class="srust sstorage stype">let</span> <span class="srust ssupport stype">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>x</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> <span class="srust skeyword soperator">=</span> <span class="srust svariable slanguage">self</span>.<span class="srust sfunction ssupport">next</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
			accum <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">f</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>accum<span class="srust spunctuation sseparator">,</span> x</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
		</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
		accum
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

	<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> et cetera
</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span></code></pre><p>Even though it looks very similar to not having async genericity at all, it is still better than without because:</p><ol><li>Overriding <code class=scode>fold_async</code> also effectively overrides <code class=scode>fold</code> - they’re able to share an implementation.</li><li>Async and sync iterators share definitions of <code class=scode>fold</code> and <code class=scode>fold_async</code>.</li></ol><p>This makes the feature still worth it in my opinion, even if we have to insert some hacks into <code class=scode>Iterator</code> to avoid breaking compatibility.</p><p>Unfortunately <code class=scode>fold</code> isn’t the only method that would need this treatment, potentially many others would too. By my count, this includes (in the standard library alone): <code class=scode>chain</code>, <code class=scode>zip</code>, <code class=scode>map</code>, <code class=scode>for_each</code>, <code class=scode>filter</code>, <code class=scode>filter_map</code>, <code class=scode>skip_while</code>, <code class=scode>take_while</code>, <code class=scode>map_while</code>, <code class=scode>scan</code>, <code class=scode>flat_map</code>, <code class=scode>flatten</code>, <code class=scode>inspect</code>, <code class=scode>collect</code>, <code class=scode>partition</code>, <code class=scode>try_fold</code>, <code class=scode>try_for_each</code>, <code class=scode>reduce</code>, <code class=scode>all</code>, <code class=scode>any</code>, <code class=scode>find</code>, <code class=scode>find_map</code>, <code class=scode>position</code>, <code class=scode>rposition</code>, <code class=scode>sum</code>, <code class=scode>product</code>, <code class=scode>cmp</code>, <code class=scode>partial_cmp</code>, <code class=scode>eq</code>, <code class=scode>ne</code>, <code class=scode>lt</code>, <code class=scode>le</code>, <code class=scode>gt</code>, <code class=scode>ge</code>, <code class=scode>DoubleEndedIterator::try_rfold</code>, <code class=scode>DoubleEndedIterator::rfold</code>, <code class=scode>DoubleEndedIterator::rfind</code> and <code class=scode>Read::chain</code>. If <code class=scode>async Clone</code> or <code class=scode>async Ord</code> become things, the list would grow longer.</p><p>It is a bit of a shame that functions like <code class=scode>map</code> and <code class=scode>Read::chain</code> have to have async versions though, since it’s not like anyone overrides <code class=scode>map</code> anyway. But because it’s <em>technically</em> possible, Rust has already promised not to break that code and so now can’t relax the signature of that function. Although who knows, maybe if we got a low % regression Crater run it would convince people that’s it’s acceptable breakage and the list could be shortened to the much more manageable <code class=scode>for_each</code>, <code class=scode>partition</code>, <code class=scode>try_fold</code>, <code class=scode>try_for_each</code>, <code class=scode>reduce</code>, <code class=scode>all</code>, <code class=scode>any</code>, <code class=scode>find</code>, <code class=scode>find_map</code>, <code class=scode>position</code>, <code class=scode>rposition</code>, <code class=scode>cmp</code>, <code class=scode>partial_cmp</code>, <code class=scode>eq</code>, <code class=scode>ne</code>, <code class=scode>lt</code>, <code class=scode>le</code>, <code class=scode>gt</code>, <code class=scode>ge</code>, <code class=scode>DoubleEndedIterator::try_rfold</code>, <code class=scode>DoubleEndedIterator::rfold</code> and <code class=scode>DoubleEndedIterator::rfind</code>. I would definitely rather do this, because frankly if you override <code class=scode>map</code> then you deserve what you get.</p><p>Out of the group, <code class=scode>collect</code>, <code class=scode>sum</code> and <code class=scode>product</code> are an especially interesting three because their <code class=scode>_async</code> versions (and their normal versions if we accept the technically breaking change) can’t use the standard <code class=scode>FromIterator</code>, <code class=scode>Product</code> and <code class=scode>Sum</code> traits since those traits are currently hardcoded to work for synchronous iterators only. So we would instead have to make new <code class=scode>*Async</code> versions of those traits with blanket implementations of the old versions:</p><pre class=scode><code><span class="srust ssource"><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Not sure how useful `~async` is here; it would only be needed for collections
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> that actually perform async work themselves while collecting as opposed to
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> just potentially-asynchronously receiving the items and then synchronously
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> collecting them.
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span>
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> This is not true of any existing `FromIterator` or `FromStream`
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> implementation currently, but there may still be use cases - who knows.
</span><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust skeyword soperator">~</span>async <span class="srust smeta sgeneric">FromAsyncIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>A<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust spunctuation sseparator">:</span> <span class="srust ssupport stype">Sized</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
    <span class="srust skeyword soperator">~</span>async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">from_async_iter</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust sillegal sinvalid">~</span></span>async <span class="srust smeta sgeneric">IntoIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Item = A<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust skeyword soperator">></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>iter<span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust sstorage stype">Self</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">FromAsyncIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>A<span class="srust spunctuation send sdefinition sgeneric">></span></span>, A<span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta simpl"> <span class="srust smeta sgeneric">FromIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>A<span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">T</span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">from_iter</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">IntoIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Item = A<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">iter</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust sstorage stype">Self</span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust sstorage stype">Self</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>from_async_iter<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>iter</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>With similar code for both <code class=scode>Sum</code> and <code class=scode>Product</code>. Unlike <code class=scode>Iterator::fold</code>, since <code class=scode>from_iter</code>, <code class=scode>sum</code> and <code class=scode>product</code> aren’t default-implemented methods we can’t just add a new <code class=scode>from_async_iter</code> function to the <code class=scode>FromIterator</code> trait itself; an entirely new trait is needed.</p><h2 id=trait-impl-implicit-bounds><a href=#trait-impl-implicit-bounds class=anchor></a>Trait impl implicit bounds</h2><p><a href=#function-implicit-bounds>Before</a>, I talked about how inside an inherent impl block, implicit <code class=scode>Drop</code> bounds to generics of the outer type would apply individually to each of the methods depending on its asynchronity, and the block itself would enforce no bounds on the type. Unfortunately, we don’t have that luxury when considering trait implementations: either the trait is implemented or it’s not and we can’t apply our own bounds to individual items.</p><p>However, we <em>do</em> know whether the trait overall should be considered asynchronous or not - whether it’s being implemented as <code class=scode>async Trait</code> or <code class=scode>Trait</code>. So we can just forward that property as the default kind of <code class=scode>Drop</code> bound, and it should be what users want most of the time. Of course, for the (hopefully) rare case that it’s <em>not</em> desired they can always override it. The most obvious time that crops up is when implementing a trait that isn’t an <code class=scode>async Trait</code> but still has async methods (i.e. an async trait with no synchronous equivalent) - then the drop bounds would end up overly restrictive:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">ExampleTrait</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">foo</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>V<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">value</span><span class="srust spunctuation sseparator">:</span> V</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">Wrapper</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span></span><span class="srust smeta sstruct"></span><span class="srust smeta sstruct"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>T</span><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta simpl"> ExampleTrait <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">Wrapper</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> overly-restrictive implied bound: `T: Drop`
</span></span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">foo</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>V<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">value</span><span class="srust spunctuation sseparator">:</span> V</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
	</span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> implied bound: `V: async Drop` (since it's declared
</span>		<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> on the function and not on the impl block)
</span>	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust ssupport smacro">todo!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>But with any luck this kind of code won’t be too common, since users should ideally be writing most code as generic-over-async anyway.</p><p>An interesting side effect of the above rule is in code like below:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">Wrapper</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span></span><span class="srust smeta sstruct"></span><span class="srust smeta sstruct"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>T</span><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> implied Drop bound <span class="srust spunctuation sdefinition scomment">*/</span></span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta simpl"> Drop <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">Wrapper</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>I am being dropped<span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Although it is not obvious, this code wouldn’t compile because the <code class=scode>Drop</code> implementation of a type has more restrictive trait bounds than the type itself, and that isn’t allowed. But since it looks like this code should compile, I find it acceptable to introduce a special case and simply have the compiler forward that implicit <code class=scode>T: Drop</code> bound to the type itself, but only when a <code class=scode>Drop</code> implementation specifically is present.</p><p>Either way, that type does not work with <code class=scode>async Drop</code> types and the fix is like so:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">Wrapper</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span></span><span class="srust smeta sstruct"></span><span class="srust smeta sstruct"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>T</span><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sseparator">:</span> <span class="srust sillegal sinvalid">?</span></span></span><span class="srust smeta simpl"><span class="srust sentity sname simpl">Drop</span>> <span class="srust sentity sname simpl">Drop</span> <span class="srust sentity sname simpl">for</span> <span class="srust sentity sname simpl">Wrapper</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>I am being dropped<span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><h2 id=async-closures><a href=#async-closures class=anchor></a>Async closures</h2><p>Supporting async genericity with closures (as required for functions like <code class=scode>Option::map</code> and <code class=scode>Iterator::fold</code>) requires <code class=scode>async {Fn, FnMut, FnOnce}</code> to exist as traits. It seems that this is a bit useless since we already have functions that return futures, but as it turns out there is an actual benefit to having separate <code class=scode>async</code> function traits, particularly when working with closures: it makes the lifetimes a lot easier to manage, since the returned futures will be able to borrow the closure and parameters - something impossible with the current design.</p><p>However in order for the <code class=scode>async Fn</code>-traits to be useful, they must be actually implemented by the relevant functions and closures. Currently, people support asynchronous callbacks by having closures that return futures (<code class=scode>|| async {}</code>) - and <code class=scode>async fn</code>s are desugared to functions of this form too. It wouldn’t be a good idea to attempt to change the behaviour of the former since that would need a hacky compiler special case for closures returning futures only, but thankfully we have reserved a bit of syntax that would be perfect for this use case: async closures (<code class=scode>async || {}</code>). If they were to evaluate to closure types implementing <code class=scode>async Fn</code> instead of <code class=scode>Fn</code>, they could be passed into async-generic functions like <code class=scode>Option::map</code> without a problem.</p><pre class=scode><code><span class="srust ssource"><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Gives an `Option&lt;T>`, since the async `map` is used.
</span><span class="srust sstorage stype">let</span> output <span class="srust skeyword soperator">=</span> some_option.<span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>async <span class="srust skeyword soperator">|</span>value<span class="srust skeyword soperator">|</span> <span class="srust sfunction ssupport">process</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>value</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Gives an `Option&lt;impl Future&lt;Output = T>>`, since the sync `map` is used.
</span><span class="srust sstorage stype">let</span> output <span class="srust skeyword soperator">=</span> some_option.<span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">|</span></span></span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust svariable sparameter">value</span><span class="srust spunctuation ssection send sparameters">|</span></span> </span><span class="srust smeta sfunction sclosure">async <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sfunction ssupport">process</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>value</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>The less good side of this addition is with <code class=scode><span class="srust ssource">async <span class="srust sfunction sstorage stype">fn</span></span></code>s: we would have to choose between keeping the current system of desugaring to a simple <code class=scode><span class="srust ssource"><span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> impl Future</span></span></code> function, and implementing the <code class=scode>async Fn</code> traits. The former is backwards compatible and more transparent (since those functions can be replicated entirely in userspace), but the latter has better interopability with async generic functions. I am inclined to choose the latter design, but it’s an unfortunate decision to have to make.</p><p>Note that it wouldn’t be possible to implement <em>both</em> <code class=scode>async Fn</code> and <code class=scode>Fn</code>, because implementing <code class=scode>Fn</code> already implies implementing <code class=scode>async Fn</code> as an async function that never awaits; we would end up with conflicting implementations of <code class=scode>async Fn</code>, one that asynchronously evaluates to <code class=scode>T</code> and one that immediately evaluates to <code class=scode>impl Future&lt;Output = T></code>. To avoid that compile error we would have to choose one and discard the other.</p><h2 id=conclusion><a href=#conclusion class=anchor></a>Conclusion</h2><p>In this post we sketched out a potential design for async drop, figuring out many details and intricacies along the way. The resulting proposal is unfortunately not a small one, however it does have much general usefulness outside of async destructors (<code class=scode>~async</code> in particular would be excellent to have for so much code) and lots of it is necessary if we are to minimize footguns.</p><p>As a summary of everything we’ve explored thus far:</p><ol><li>We figured out the desired edge case semantics of async drop during cancellation, panics and assignments, in synchronous functions and with generics.</li><li>We explored a system for async destructors based on destructor futures instead of <code class=scode>poll_drop_ready</code>.</li><li>We explored a mechanism for supporting code that is generic over whether it is <code class=scode>async</code> or not.</li><li>We hypothesized what is best to apply as the default generic drop bounds in functions, as well as how to relax and strengthen them if necessary.</li><li>We considered how async genericity would impact functions and closures.</li></ol><p>This post doesn’t attempt to provide a final design for async drop - there are still many open questions (e.g. <code class=scode>UnwindSafe</code>, <code class=scode>?Drop</code> syntax, <code class=scode><span class="srust ssource"><span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#!</span><span class="srust spunctuation ssection sbegin sgroup">[</span><span class="srust svariable sannotation">no_std</span><span class="srust spunctuation ssection send sgroup">]</span></span></span></code> support) and likely unknown unknowns. But it does attempt to properly explore one particular design to evaluate its complexity, feasability and usefulness. Out of all possible options, I think it to be quite a promising one and definitely possible to implement in some form.</p><p>Many thanks to Yoshua Wuyts for proofreading this for me!</p><h2 id=completion-futures><a href=#completion-futures class=anchor></a>Appendix A: Completion futures</h2><p>Completion futures are a concept for a special type of future that is guaranteed at compile-time to not be prematurely dropped or leaked, in contrast to regular futures which can be stopped without warning at any time. It doesn’t sound like much, but completion futures are actually incredibly useful:</p><ul><li>They enable <code class=scode>spawn</code> and <code class=scode>spawn_blocking</code> functions that don’t restrict the future’s lifetime to <code class=scode>'static</code>.</li><li>They enable creating zero-cost wrappers around completion-based APIs like <code class=scode>io_uring</code>, IOCP and libusb.</li><li>They enables better interopability with C++ futures, which have this guarantee by default.</li></ul><p>I have previously written <a href=https://github.com/SabrinaJewson/completion>a library for this</a> but it was very limited because it fundamentally needed to rely on <code class=scode>unsafe</code>, infecting just about every use of it with <code class=scode>unsafe</code> as well which was really not ideal. But it turns out that with an async destructor design like the one proposed by this post, it is much easier to support them in an even more powerful way and with minimal <code class=scode>unsafe</code>.</p><p>The solution is to add a single new trait to the core library:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage smodifier">unsafe</span> auto <span class="srust smeta strait"><span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">Leak</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>As an auto trait, it would be implemented for every single type other than a special <code class=scode>core::marker::PhantomNoLeak</code> marker and any type transitively containing that. What <code class=scode>Leak</code> represents is the ability to safely leak an instance of the type, via <a href=https://doc.rust-lang.org/stable/std/mem/fn.forget.html><code class=scode>mem::forget</code></a>, reference cycles or anything similar. If a type opts out of implementing it, it is guaranteed that from creation, its <code class=scode>Drop</code> or <code class=scode>async Drop</code> implementation will be run if the type’s lifetime to end.</p><p>The standard library would have all the “leaky” APIs like <code class=scode>Arc</code>, <code class=scode>Rc</code>, <code class=scode>ManuallyDrop</code> and <code class=scode>MaybeUninit</code> require that <code class=scode>Leak</code> be implemented on the inner type, to avoid safe code being able to circumvent the restriction. Other than that, most other APIs would support both <code class=scode>Leak</code> and <code class=scode>!Leak</code> types, since they will run the destructor of inner values.</p><p>And this is all we need to support completion futures. An <code class=scode>io_uring</code> I/O operation future can be implemented by submitting the operation on creation and waiting for it to complete on drop, and the <code class=scode>!Leak</code> guarantee means that the <a href=https://github.com/spacejam/rio/issues/30>use-after-free issue</a> <code class=scode>io_uring</code> libraries currently have to work around is eliminated.</p><p>This is a very powerful feature, even more so than my old <code class=scode>unsafe</code>-based implementation. Because it guarantees not leaking from creation and not just from the first poll, scoped tasks don’t even need a special scope to be defined (à la <a href=https://docs.rs/crossbeam/0.8/crossbeam/fn.scope.html>Crossbeam</a>). Instead, an API like this just works:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage smodifier">pub</span> async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">spawn</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, R, F<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">f</span><span class="srust spunctuation sseparator">:</span> F</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">JoinHandle<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, R<span class="srust spunctuation send sdefinition sgeneric">></span></span>
</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	F<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Future<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Output = R<span class="srust spunctuation send sdefinition sgeneric">></span></span> + Send + <span class="srust sstorage smodifier slifetime">'a</span>,
	R<span class="srust spunctuation sseparator">:</span> Send,
</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>It also has impacts on synchronous code, because <a href=https://doc.rust-lang.org/stable/std/thread/fn.spawn.html><code class=scode>thread::spawn</code></a> gets to be extended in a similar way:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage smodifier">pub</span> <span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">spawn_scoped</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, R, F<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">f</span><span class="srust spunctuation sseparator">:</span> F</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">JoinHandle<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, R<span class="srust spunctuation send sdefinition sgeneric">></span></span>
</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	F<span class="srust spunctuation sseparator">:</span> FnOnce<span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust spunctuation ssection send sgroup">)</span> -> R + Send + <span class="srust sstorage smodifier slifetime">'a</span>,
	R<span class="srust spunctuation sseparator">:</span> Send,
</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>This would allow you to write code that borrows from the stack without problems:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">let</span> message <span class="srust skeyword soperator">=</span> <span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>Hello World<span class="srust spunctuation send sdefinition sstring">"</span></span>.<span class="srust sfunction ssupport">to_owned</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Synchronous code
</span><span class="srust sstorage stype">let</span> thread_1 <span class="srust skeyword soperator">=</span> <span class="srust smeta spath">thread<span class="srust spunctuation saccessor">::</span></span>spawn_scoped<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">|</span></span></span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">|</span></span> </span><span class="srust smeta sfunction sclosure"><span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{message}</span><span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> thread_2 <span class="srust skeyword soperator">=</span> <span class="srust smeta spath">thread<span class="srust spunctuation saccessor">::</span></span>spawn_scoped<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">|</span></span></span><span class="srust smeta sfunction sclosure"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">|</span></span> </span><span class="srust smeta sfunction sclosure"><span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{message}</span><span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
thread_1.<span class="srust sfunction ssupport">join</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
thread_2.<span class="srust sfunction ssupport">join</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Asynchronous code
</span><span class="srust sstorage stype">let</span> task_1 <span class="srust skeyword soperator">=</span> <span class="srust smeta spath">task<span class="srust spunctuation saccessor">::</span></span>spawn<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>async <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{message}</span><span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> task_2 <span class="srust skeyword soperator">=</span> <span class="srust smeta spath">task<span class="srust spunctuation saccessor">::</span></span>spawn<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>async <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{message}</span><span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
task_1.await.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
task_2.await.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>Neat, right?</p><p>As with many things it needs an edition boundary to implement fully: In the current edition, every generic parameter has to still imply <code class=scode>T: Leak</code> but in future editions that can be relaxed to <code class=scode>T: ?Leak</code>, allowing the small subset of APIs that <em>can</em> leak values (<code class=scode>Arc</code>, <code class=scode>Rc</code>, <code class=scode>mem::forget</code>, <code class=scode>ManuallyDrop</code>, etc) to declare so in their signature and the majority of APIs to have the less restrictive bound by default.</p><h2 id=weakly-async-functions><a href=#weakly-async-functions class=anchor></a>Appendix B: Weakly async functions</h2><p>With the current design, there ends up being a large number of functions with the specific property that they need to be <code class=scode><span class="srust ssource">async <span class="srust sfunction sstorage stype">fn</span></span></code>s if a type they deal with is <code class=scode>async Drop</code>, for the sole reason that they are able to panic while they have that type in scope. I listed a few at the start of the <a href=#async-genericity>async genericity</a> section, including <code class=scode>HashMap::{insert, entry}</code>, <code class=scode>Vec::push</code> and <code class=scode>Box::new</code>, but there’s one particularly relevant one here which is <code class=scode>task::spawn</code> (as seen in various runtimes: <a href=https://docs.rs/tokio/1/tokio/task/fn.spawn.html>tokio</a>, <a href=https://docs.rs/async-std/1/async_std/task/fn.spawn.html>async-std</a>, <a href=https://docs.rs/glommio/0.7/glommio/fn.spawn_local.html>glommio</a>, <a href=https://docs.rs/smol/1/smol/fn.spawn.html>smol</a>).</p><p>Across all those runtimes, <code class=scode>task::spawn</code> has the ability to panic before it spawns the future, which commonly can happen if the runtime is not running, but can also theoretically happen if allocation fails or there’s some other random system error. The problem is that just because of this one small edge case (and their presumed desire to support <code class=scode>async Drop</code> futures), <code class=scode>task::spawn</code> is forced to be a full <code class=scode>async fn</code> even though <em>in itself</em> it doesn’t do any <code class=scode>async</code> work.</p><p>This is especially bad for <code class=scode>task::spawn</code> as a function because it can easily trip up those who are migrating code. For example, while before this code would run the task in parallel with <code class=scode><span class="srust ssource"><span class="srust sfunction ssupport">other_work</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span></code>:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">let</span> task <span class="srust skeyword soperator">=</span> <span class="srust smeta spath">task<span class="srust spunctuation saccessor">::</span></span>spawn<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>some_future</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sfunction ssupport">other_work</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
task.await<span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>With the changes applied it would instead run <code class=scode><span class="srust ssource"><span class="srust sfunction ssupport">other_work</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span></code> and wait for it to complete, and <em>then</em> spawn the task and not even wait for it to finish! (Unless of course dropping a task handle would be changed to implicitly join the task, which <em>may</em> be a better design overall - but the point still stands because it doesn’t run in parallel as people would expect.)</p><p>The fixed version would look like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">let</span> task <span class="srust skeyword soperator">=</span> <span class="srust smeta spath">task<span class="srust spunctuation saccessor">::</span></span>spawn<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>some_future</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
<span class="srust sfunction ssupport">other_work</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
task.await<span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>But given that the old version doesn’t even fail to compile, it’s not an ideal situation to be in. Additionally, it does just look weird having a future that resolves to…another future.</p><p>My proposed solution to this problem is to add a new type of function to the language called “weakly async functions” which are in between asynchronous functions and synchronous functions. Let’s denote it here with <code class=scode>[async] fn</code>, but the syntax is obviously up for bikeshedding. The idea is this:</p><ul><li><code class=scode>[async] fn</code>s either complete synchronously or panic asynchronously.</li><li>Because they must complete synchronously, they cannot be cancelled and thus they don’t need to be <code class=scode>.await</code>ed - that can be made implicit.</li><li>Because they panic asynchronously, they bypass the panic check and are allowed to own types with asynchronous destructors across potential panic points (but are not allowed to drop them unless via a panic).</li><li>They are allowed to call regular <code class=scode>fn</code>s and other <code class=scode>[async] fn</code>s, but not <code class=scode>async fn</code>s.</li><li>They cannot be called from within synchronous functions.</li><li>They are not allowed to recurse, just like <code class=scode>async fn</code>s.</li><li>It is not a breaking change to convert from an <code class=scode>[async] fn</code> to a regular fn.</li></ul><p>This way, <code class=scode>task::spawn</code> (and a bunch of other functions like <code class=scode>Box::new</code>, <code class=scode>Box::pin</code>, <code class=scode>Vec::push</code>, <code class=scode>Result::unwrap</code> etc) would avoid requiring <code class=scode>.await</code>s when being called with <code class=scode>async Drop</code> types. This solves the above footgun while also contributing to the succintness of code. <code class=scode>task::spawn</code> would be defined something like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage smodifier">pub</span> <span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">[</span>async<span class="srust spunctuation ssection send sgroup">]</span></span> <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">spawn</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>O, F<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">JoinHandle<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>O<span class="srust spunctuation send sdefinition sgeneric">></span></span>
</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	F<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Future<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Output = O<span class="srust spunctuation send sdefinition sgeneric">></span></span> + Send + ?Drop + async Drop + <span class="srust sstorage smodifier slifetime">'static</span>,
	O<span class="srust spunctuation sseparator">:</span> Send,
</span></span></code></pre><p>And in asynchronous contexts would be callable with just <code class=scode>task::spawn(future)</code>, no await necessary.</p><p>When inside generic code, <code class=scode>[async]</code> would be treated as another state that <code class=scode>~async fn</code>s can be in, meaning there are actually three ways to those functions. There would additionally be <code class=scode>~[async] fn</code>s for functions that can be either <code class=scode>fn</code>s or <code class=scode>[async] fn</code>s, but not <code class=scode>async fn</code>s.</p><p>You’d also need a special kind of bound to represent “<code class=scode>Drop</code> when the function is synchronous and <code class=scode>async Drop</code> when the function is <code class=scode>async</code>, but also <code class=scode>async Drop</code> when the function is <code class=scode>[async]</code>, since this function does not drop a value of this type unless it panics”. For now I will use the incredibly verbose form <code class=scode>~[async] async Drop</code> to represent this, but if this feature is actually added a better and more bikeshedded syntax will probably have to be chosen.</p><p>This is the feature that allows us to define <code class=scode>Vec::push</code> generically:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">Vec</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust skeyword soperator">~</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">[</span>async<span class="srust spunctuation ssection send sgroup">]</span></span> <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">push</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">item</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
	</span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		T<span class="srust spunctuation sseparator">:</span> ?Drop + ~[async] async Drop,
	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> "Expanded" version
</span><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">Vec</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation send sdefinition sgeneric">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">push_sync</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">item</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
	</span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		T<span class="srust spunctuation sseparator">:</span> Drop,
	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
	<span class="srust skeyword soperator">~</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">[</span>async<span class="srust spunctuation ssection send sgroup">]</span></span> <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">push_weak_async</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span>, <span class="srust svariable sparameter">item</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
	</span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
		T<span class="srust spunctuation sseparator">:</span> ?Drop + async Drop,
	</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Remember that this function can drop <code class=scode>item</code> and so can’t be fully synchronous, but also doesn’t drop <code class=scode>item</code> unless it’s panicking and so shouldn’t be made fully <code class=scode>async</code> either. As such it uses the in-between, supporting <code class=scode>async Drop</code> (and therefore also <code class=scode>[async] Drop</code>) when it is an <code class=scode>[async] fn</code> and <code class=scode>Drop</code> when it is a <code class=scode>fn</code>.</p><p>Unlike completion futures, I’m not so certain whether this is a good idea or not, or whether there aren’t any other simpler alternatives. But I do definitely think there is a problem here that does need to be addressed somehow, and to me this seems the best way to do it.</p><h2 id=linear-types><a href=#linear-types class=anchor></a>Appendix C: Linear types</h2><p>I feel that I have to mention linear types at least once, given how much discourse there has been about them. A linear type is defined as “a type that must be used exactly once”. It turns out this definition is slightly vague, because it can refer to two things:</p><ol><li>Types which do not have any kind of <code class=scode>Drop</code> implementation and must be handled explicitly, but can be leaked with functions like <a href=https://doc.rust-lang.org/stable/std/mem/fn.forget.html><code class=scode>mem::forget</code></a>.</li><li>Types which do have destructors and so can implicitly fall out of scope, but can’t be leaked with functions like <a href=https://doc.rust-lang.org/stable/std/mem/fn.forget.html><code class=scode>mem::forget</code></a> (so they are guaranteed to be able to run code before falling out of scope).</li></ol><p>The former is a more common definition of linear types, and allows for types to force their users to be more explicit about what happens to them when they’re destroyed. I don’t have a proposal for this, but simply by coincidence the proposed <code class=scode>?Drop</code> bound feature does orient itself towards supporting linear types of this sort in future and although personally I do not think they will be worth adding, their viability has been increased as a side-effect.</p><p>The latter definition is what is implemented by the above <a href=#completion-futures>completion futures</a> proposal. In a way it’s not true linear types, but it’s the only one that gives the practical benefits of things like zero-cost <code class=scode>io_uring</code> and scoped tasks. It is also a lot less difficult to integrate into existing Rust code, which tends to rely quite heavily on destructors existing but not so much on values being safely leakable.</p><h2 id=uncancellable-futures><a href=#uncancellable-futures class=anchor></a>Appendix D: Uncancellable futures</h2><p>I previously argued against <a href=https://carllerche.netlify.app/2021/06/17/six-ways-to-make-async-rust-easier/ >Carl Lerche’s suggestion to make all async functions uncancellable</a> in favour of defining consistent semantics for <code class=scode>.await</code> rather than removing it. However, these kinds of functions not totally off the table; such a feature can still definitely exist, first of all as a userspace combinator:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage smodifier">pub</span> async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">must_complete</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>F<span class="srust spunctuation sseparator">:</span> Future<span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">fut</span><span class="srust spunctuation sseparator">:</span> F</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">F</span><span class="srust spunctuation saccessor">::</span></span></span>Output</span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	MustComplete<span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>fut</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sbegin sgroup">[</span><span class="srust svariable sannotation">pin_project</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">PinnedDrop</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span></span><span class="srust spunctuation ssection send sgroup">]</span></span>
<span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">MustComplete</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>F<span class="srust spunctuation sseparator">:</span> Future<span class="srust spunctuation send sdefinition sgeneric">></span></span></span></span><span class="srust smeta sstruct"></span><span class="srust smeta sstruct"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>#[pin] F</span><span class="srust spunctuation ssection send sgroup">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>F<span class="srust spunctuation sseparator">:</span> Future <span class="srust skeyword soperator">+</span> <span class="srust sillegal sinvalid">?</span></span></span><span class="srust smeta simpl"><span class="srust sentity sname simpl">Drop</span> + <span class="srust sentity sname simpl">async</span> <span class="srust sentity sname simpl">Drop</span>> <span class="srust sentity sname simpl">Future</span> <span class="srust sentity sname simpl">for</span> <span class="srust sentity sname simpl">MustComplete</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>F<span class="srust spunctuation send sdefinition sgeneric">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust sentity sname stype">Output</span> <span class="srust skeyword soperator">=</span> <span class="srust smeta spath">F<span class="srust spunctuation saccessor">::</span></span>Output<span class="srust spunctuation sterminator">;</span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">poll</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self</span>: <span class="srust smeta sgeneric">Pin<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust sstorage stype">Self</span><span class="srust spunctuation send sdefinition sgeneric">></span></span>, <span class="srust svariable sparameter">cx</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta spath">task<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric">Context<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Poll<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Output<span class="srust spunctuation send sdefinition sgeneric">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust svariable slanguage">self</span>.<span class="srust sfunction ssupport">project</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.<span class="srust sconstant snumeric sfloat">0.</span><span class="srust sfunction ssupport">poll</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>cx</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sbegin sgroup">[</span><span class="srust svariable sannotation">pinned_drop</span><span class="srust spunctuation ssection send sgroup">]</span></span>
<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>F<span class="srust spunctuation sseparator">:</span> Future<span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta simpl"> <span class="srust sentity sname simpl">async</span> <span class="srust sentity sname simpl">PinnedDrop</span> <span class="srust sentity sname simpl">for</span> <span class="srust sentity sname simpl">MustComplete</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>F<span class="srust spunctuation send sdefinition sgeneric">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	async <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sfunction sstorage stype">fn</span> </span><span class="srust sfunction sentity sname">drop</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self</span>: <span class="srust smeta sgeneric">Pin<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust sstorage stype">Self</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust svariable slanguage">self</span>.<span class="srust sfunction ssupport">project</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.<span class="srust sconstant snumeric sfloat">0.</span>await<span class="srust spunctuation sterminator">;</span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Usable like so:</p><pre class=scode><code><span class="srust ssource"><span class="srust sfunction ssupport">must_complete</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span>async <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sfunction ssupport">some_very_important_work</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
	<span class="srust sfunction ssupport">that_must_not_be_interrupted</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sbegin sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>.await<span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection send sgroup">)</span></span>
.await<span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>It could also exist as a language feature, which would additionally allow removing <code class=scode>.await</code> if that is desired. Either way, the effect is the same: this proposal easily enables writing futures that are guaranteed to not have cancellation points. Personally I do not think this use case is common enough to warrant a language feature, but it is still definitely worth considering.</p><p class=back><a href=#>⮬ Back to top</a></p></main></body></html>