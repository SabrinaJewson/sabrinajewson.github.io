<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1"name=viewport><meta content="dark light"name=color-scheme><meta content=#ffffff name=theme-color media=(prefers-color-scheme:light)><meta content=#000000 name=theme-color media=(prefers-color-scheme:dark)><meta content="Sabrina Jewson"property=og:site_name><link href=/favicon.ico rel=icon><link href=/apple-touch-icon.png rel=apple-touch-icon><link href=/common.css rel=stylesheet><title>“Truly Hygienic” Let Statements in Rust - Sabrina Jewson</title><meta content="“Truly Hygienic” Let Statements in Rust"property=og:title><meta content="Remon is a responsible library developer. She cares about stability, flexibility and correctness, using whichever tools are presently accessible to achieve those goals. Her authored libraries feature automated testing and extensive documentation; she allots design decisions rationale; she knows her language features and traditions and how to apply them to best effect."name=description><meta content=article property=og:type><link href=post.css rel=stylesheet><link href=feed.xml rel=alternate title="Sabrina Jewson's Blog"type=application/atom+xml></head><body><header><a href=/ class=name>Sabrina Jewson</a><nav><a href=/reviews>Reviews</a> <a href=/blog/ >Blog</a></nav></header><main><h1>“Truly Hygienic” Let Statements in Rust</h1><p id=published><time datetime=2024-09-22>2024-09-22</time></p><nav></nav><p>Remon is a responsible library developer. She cares about stability, flexibility and correctness, using whichever tools are presently accessible to achieve those goals. Her authored libraries feature automated testing and extensive documentation; she allots design decisions rationale; she knows her language features and traditions and how to apply them to best effect.</p><p>And, somewhere to be discovered bound in the tangle of <code class=scode>.rs</code> files, there is Remon herself, tranquil and yet focused, meticulously crafting, polishing, studying and crafting again, a component she forsees to ease the life of her users, provides ergonomics inaccessible by traditional methods, brings to life the great gift of syntax without glue added to the cogs of the build process – a declarative macro.</p><p>Refined and learned code-witch she is, Remon is keenly aware of Rust Cultures and Traditions, and so in keeping, would do nothing but summon a monstrous (documented, without doubt, but monstrous nonetheless) tornado of dollar signs and brackets, one whose gales would surely lift up and send flying a meek blog post as this one. Have sympathy! I cannot handle that – I must admit I have not even implemented <code class=scode><span class="srust ssource"><span class="srust stype ssupport">Send</span></span></code>, so the results could verge on disastrous. But a trained magician knows better than to create a beast they cannot tame, and so for this chronicle it is simplified to a wisp of its wild self – one where you must excuse the apparent folly of its existence – as follows:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta smacro"><span class="srust sfunction ssupport">macro_rules!</span> <span class="srust smacro sentity sname">oh_my</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword soperator">=></span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust stype sstorage">let</span> <span class="srust stype ssupport">Ok</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span>x</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">read_input</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword scontrol">else</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust skeyword scontrol">return</span> <span class="srust stype ssupport">Err</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span>Error</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
		<span class="srust svariable sother">$crate</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>process<span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span>x</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
	<span class="srust spunctuation ssection send sblock">}</span></span>;
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Remon is a responsible library developer, and understands that all humans will make mistakes – and so she has solicited the services of a good friend, Wolfie, to comment on this slice of code.</p><p>Well, Wolfie says, this macro is very impressive feat, and shall surely ease the lives of our users, provide ergonomics inaccessible by traditional methods, and bring to life the great gift of syntax without glue added to the cogs of the build process. But I do have one concern – the <code class=scode><span class="srust ssource"><span class="srust stype sstorage">let</span></span></code> in this macro is not hygienic.</p><p>Now, Remon has read her literature, and knows that Rust macros <em>are</em> hygienic with regards to locals – they are guaranteed not to interfere with variables of the caller’s scope unless the variable’s name is explicitly passed in.</p><p>Is that so?, asks Remon. You and I both know that Rust macros use mixed-site hygiene. But I trust your experience as a developer and respect you as a person, so I will approach this incongruence with curiosity rather than dismissal. Thus I must ask you: Whatever do you mean?</p><p>Wolfie thinks for a second, and concludes this point best communicated through the medium of code. So he quickly types out a demo of a certain way of use causing bugs:</p><pre class=scode><code><span class="srust ssource"><span class="srust stype sstorage">const</span> x<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust stype sstorage">str</span> <span class="srust skeyword soperator">=</span> <span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>26ad109e6f4d14e5cc2c2ccb1f5fb497abcaa223<span class="srust spunctuation send sdefinition sstring">"</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust ssupport smacro">oh_my!</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>And upon entering input that is not the latest commit hash of the greatest Rust library of all time, Remon is dismayed and ashamed to discover that the code, incorrectly, results in an error. But it’s at least not hard to discover <em>why</em>: in the line containing <code class=scode><span class="srust ssource"><span class="srust stype sstorage">let</span> <span class="srust stype ssupport">Ok</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span>x</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword soperator">=</span></span></code>, <code class=scode>x</code> is a identifier pattern, which means it can either refer to a constant if the constant is in scope, or create a new variable otherwise. Of course, the macro <em>expects</em> the latter to happen, but since constants are items, and thus unlike variables are unhygienic, if there is a constant <code class=scode>x</code> at the call site, it will be used instead. So our pattern becomes equivalent to <code class=scode><span class="srust ssource"><span class="srust stype ssupport">Ok</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>26ad109…<span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span></span></code>, which will of course reject any value that is not the latest commit hash of the greatest Rust library of all time, resulting in silent bugs.</p><p>Okay, thinks Remon. I know of a way to fix this: the pattern <code class=scode>IDENT @ PATTERN</code> will unambiguously have <code class=scode>IDENT</code> bound as a variable, never to be treated as a constant. Since there are no other restrictions to be placed on the data, our <code class=scode>PATTERN</code> can simply be a wildcard – <code class=scode>_</code>. So that’s what she does:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta smacro"><span class="srust sfunction ssupport">macro_rules!</span> <span class="srust smacro sentity sname">oh_my</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword soperator">=></span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		<span class="srust stype sstorage">let</span> <span class="srust stype ssupport">Ok</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span>x <span class="srust skeyword soperator">@</span> <span class="srust skeyword soperator">_</span></span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">read_input</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword scontrol">else</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust skeyword scontrol">return</span> <span class="srust stype ssupport">Err</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span>Error</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
		<span class="srust svariable sother">$crate</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>process<span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span>x</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
	<span class="srust spunctuation ssection send sblock">}</span></span>;
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>But Wolfie is still not pleased, and Remon is still surprised, because now there is a compilation error.</p><pre class=scode><code>error[E0530]: let bindings cannot shadow constants
 --> src/main.rs:3:10
  |
3 |         let Ok(x @ _) = read_input() else { return Err(Error) };
  |                ^ cannot be named the same as a constant
...
8 |     const x: &str = "TODO";
  |     ---------------------- the constant `x` is defined here
9 |     oh_my!();
  |     -------- in this macro invocation
  |
</code></pre><p>This is of course not as bad as buggy behaviour, but Wolfie knows that Remon is a responsible library developer who cares about flexibility and correctness, and it is unpredicable that the macro would suddenly start failing just because of some constants that happen to be there at the call site.</p><p>Remon has never seen this error before, but remains undeterred. After all, there is one more trick up her sleeve: although <code class=scode><span class="srust ssource"><span class="srust stype sstorage">let</span></span></code> bindings cannot shadow constants, those two do not account for every member of the value namespace. Functions are a member just as well. And functions, unlike <code class=scode><span class="srust ssource"><span class="srust stype sstorage">const</span></span></code>s, have the property that they <em>can</em> be shadowed – and by virtue of being an item, they may shadow the latter as well (if introduced in a smaller scope).</p><p>So, she introduces that new scope into her macro, and inside it, defines a dummy function. As it happens, functions are never valid in patterns, and so the <code class=scode>x @ _</code> trick is no longer needed.</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta smacro"><span class="srust sfunction ssupport">macro_rules!</span> <span class="srust smacro sentity sname">oh_my</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword soperator">=></span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
        <span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation ssection sgroup sbegin">[</span><span class="srust sannotation svariable">allow</span><span class="srust smeta sparameters sannotation"><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust sgroup smeta">dead_code</span></span><span class="srust smeta sparameters sannotation"><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust spunctuation ssection sgroup send">]</span></span>
        <span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust stype sstorage sfunction">fn</span> </span><span class="srust sfunction sentity sname">x</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
		<span class="srust stype sstorage">let</span> <span class="srust stype ssupport">Ok</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span>x</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">read_input</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword scontrol">else</span> <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> <span class="srust skeyword scontrol">return</span> <span class="srust stype ssupport">Err</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span>Error</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
		<span class="srust svariable sother">$crate</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>process<span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup sbegin">(</span>x</span><span class="srust sgroup smeta"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
    </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation ssection send sblock">}</span></span>;
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>And despite Wolfie’s attempts to break it, this iteration remains hygienic even in the presence of strange environments.</p><p>But Remon isn’t satisfied. Because now, being the responsible library developer she is, whenever she uses this trick, she must document it. And she has to introduce a shadowing helper function for every single identifier used in the macro – something that is very easy to forget, negating the benefit of using this trick in the first place. It increases her codebase’s size, in an already-complex macro, for a gain that seems marginal at best.</p><p>And so, against her instincts to be fully correct, Remon turns to Wolfie and says, plainly, <em>No</em>. With the incantation of a <code class=scode><span class="ssource sbash sshell"><span class="smeta sfunction-call sshell"><span class="svariable sfunction sshell">git</span></span><span class="smeta sfunction-call sshell sarguments"> reset</span></span></code>, she erases these changes from history, choosing instead to live in the ignorant bliss of very-slightly-unhygienic declarative macros.</p><p>After all, who names constants in lowercase anyway?</p><p class=back><a href=#>⮬ Back to top</a></p></main></body></html>