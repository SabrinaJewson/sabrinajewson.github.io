<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1"name=viewport><meta content="dark light"name=color-scheme><meta content=#ffffff name=theme-color media=(prefers-color-scheme:light)><meta content=#000000 name=theme-color media=(prefers-color-scheme:dark)><meta content="Sabrina Jewson"property=og:site_name><link href=/favicon.ico rel=icon><link href=/apple-touch-icon.png rel=apple-touch-icon><link href=/common.css rel=stylesheet><title>The Better Alternative to Lifetime GATs - Sabrina Jewson</title><meta content="The Better Alternative to Lifetime GATs"property=og:title><meta content="Update (2022-05-30): danielhenrymantilla recently released a crate, nougat, which provides a proc macro that allows you to use the technique presented in this article with the same syntax as regular GATs. I encourage you to check it out!"name=description><meta content=article property=og:type><link href=post.css rel=stylesheet><link href=feed.xml rel=alternate title="Sabrina Jewson's Blog"type=application/atom+xml></head><body><header><a href=/ class=name>Sabrina Jewson</a><nav><a href=/blog/ >Blog</a></nav></header><main><h1>The Better Alternative to Lifetime GATs</h1><p id=published><time datetime=2022-05-01>2022-05-01</time> (updated <time datetime=2022-05-30>2022-05-30</time>)</p><nav><ul><li><a href=#where-real-gats-fall-short>Where real GATs fall short</a></li><li><a href=#what-went-wrong>What went wrong?</a></li><li><a href=#dyn-trait-as-a-hkt>Workaround 1: <code class=scode>dyn Trait</code> as a HKT</a></li><li><a href=#hrtb-supertrait>Workaround 2: HRTB supertrait</a></li><li><a href=#hrtb-implicit-bounds>HRTB implicit bounds</a></li><li><a href=#the-better-gats>Workaround 3: The better GATs</a></li><li><a href=#dyn-safety>Dyn safety</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav><p>Update (2022-05-30): <a href=https://github.com/danielhenrymantilla>danielhenrymantilla</a> recently released a crate, <a href=https://docs.rs/nougat>nougat</a>, which provides a proc macro that allows you to use the technique presented in this article with the same syntax as regular GATs. I encourage you to check it out!</p><h2 id=where-real-gats-fall-short><a href=#where-real-gats-fall-short class=anchor></a>Where real GATs fall short</h2><p><a href=https://github.com/rust-lang/rust/issues/44265>GATs</a> are an unstable feature of Rust, likely to be stabilized in the next few versions, that allow you to add generic parameters on associated types in traits. The motivating example for this feature is the “lending iterator” trait, which allows you to define an iterator for which only one of its items can exist at any given time. With lifetime GATs, its signature would look something like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIterator</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust skeyword soperator">></span>
	<span class="srust skeyword sother">where</span>
		<span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sterminator">;</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span><span class="srust smeta sgeneric">Item<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>and it would allow you to implement iterators you otherwise wouldn’t have been able to, like <code class=scode>WindowsMut</code> (since the slices it returns overlap, a regular iterator won’t work):</p><pre class=scode><code><span class="srust ssource"><span class="srust skeyword sother">use</span> <span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span><span class="srust smeta spath">core<span class="srust spunctuation saccessor">::</span></span>mem<span class="srust spunctuation sterminator">;</span>

<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">windows_mut</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span>
	<span class="srust svariable sparameter">slice</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> [T],
</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust ssupport smacro">assert_ne!</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sother sconstant">WINDOW_SIZE</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">0</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
	WindowsMut <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span> slice<span class="srust spunctuation sseparator">,</span> first<span class="srust spunctuation sseparator">:</span> <span class="srust sconstant slanguage">true</span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta sstruct"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust smeta sstruct"> </span><span class="srust smeta sstruct"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sother smember svariable">slice</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust sstorage smodifier">mut</span> [T],
	<span class="srust sother smember svariable">first</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">bool</span>,
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIterator</span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust skeyword soperator">></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span>T<span class="srust spunctuation sseparator">;</span> <span class="srust sother sconstant">WINDOW_SIZE</span><span class="srust spunctuation ssection sgroup send">]</span></span> <span class="srust skeyword sother">where</span> <span class="srust sentity sname slabel">'a</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sterminator">;</span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span><span class="srust smeta sgeneric">Item<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
		<span class="srust skeyword scontrol">if</span> <span class="srust skeyword soperator">!</span><span class="srust svariable slanguage">self</span>.first <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
			<span class="srust svariable slanguage">self</span>.slice <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta spath">mem<span class="srust spunctuation saccessor">::</span></span>take<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable slanguage">self</span>.slice</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust skeyword soperator">..</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
		</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
		<span class="srust svariable slanguage">self</span>.first <span class="srust skeyword soperator">=</span> <span class="srust sconstant slanguage">false</span><span class="srust spunctuation sterminator">;</span>

		<span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust svariable slanguage">self</span>.slice.<span class="srust sfunction ssupport">get_mut</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">..</span><span class="srust sother sconstant">WINDOW_SIZE</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust skeyword soperator">?</span>.<span class="srust sfunction ssupport">try_into</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Great! That’s our <code class=scode>LendingIterator</code> trait, done and dusted, and we’ve proven that it works. End of article.</p><p>Well, before we go let’s just try one last thing: actually consuming the <code class=scode>WindowsMut</code> iterator. There’s no need to really because I’m sure it’ll work, but we’ll do it anyway for the learning experience, right?</p><p>So first we’ll define a function that prints each element of a lending iterator. This is pretty simple, we just have to use <a href=https://doc.rust-lang.org/nomicon/hrtb.html>HRTBs</a> to write the trait bound and a <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">while</span> <span class="srust sstorage stype">let</span></span></code> loop for the actual consumption.</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">print_items</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">iter</span><span class="srust spunctuation sseparator">:</span> I</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
</span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	I<span class="srust spunctuation sseparator">:</span> LendingIterator,
	<span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">I</span><span class="srust spunctuation saccessor">::</span></span></span><span class="srust smeta sgeneric">Item<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sseparator">:</span> Debug,
</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust skeyword scontrol">while</span> <span class="srust sstorage stype">let</span> <span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span>item</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword soperator">=</span> iter.<span class="srust sfunction ssupport">next</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
		<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{item:?}</span><span class="srust spunctuation sdefinition send sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>All good so far, this compiles fine. Now we’ll actually call it with an iterator:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta spath">print_items<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span>, <span class="srust skeyword soperator">_</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">windows_mut</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>This should obviously compile since <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation sseparator">;</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation ssection sgroup send">]</span></span></span></code> is definitely <code class=scode>Debug</code>. So we can just run <code class=scode>cargo run</code> and see the ou–</p><pre class=scode><code>error[E0716]: temporary value dropped while borrowed
  --> src/main.rs:45:58
   |
45 |     print_items::&lt;WindowsMut&lt;'_, _, 2>>(windows_mut(&mut [1, 2, 3]));
   |     -----------------------------------------------------^^^^^^^^^--
   |     |                                                    |
   |     |                                                    creates a temporary which is freed while still in use
   |     argument requires that borrow lasts for `'static`
46 | }
   | - temporary value is freed at the end of this statement
</code></pre><p>oh.</p><p>oh no.</p><h2 id=what-went-wrong><a href=#what-went-wrong class=anchor></a>What went wrong?</h2><p>Clearly, something’s not right here. rustc is telling us that for some reason, our borrow of the array <code class=scode><span class="srust ssource"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span></span></code> is required to live for <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> — but we haven’t written any <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> bounds anywhere, so this doesn’t really make much sense. We’ll have to put ourselves in the mindset of the compiler for a bit so that we can try to figure out what’s happening.</p><p>First of all, we create an iterator of <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'0, <span class="srust sstorage stype">i32</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></code>, where <code class=scode>'0</code> is the name of some local lifetime (notably, this lifetime is necessarily shorter than <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code>). Then we pass this iterator type into the function <code class=scode>print_items</code>, in doing so setting its <code class=scode>I</code> generic parameter to the aforementioned type <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'0, <span class="srust sstorage stype">i32</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></code>.</p><p>So now we just need to make sure that the trait bounds hold. Substituting <code class=scode>I</code> for its actual type in the <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span></span></code> clause of <code class=scode>print_items</code>, we get this bound that needs to be checked:</p><pre class=scode><code><span class="srust ssource"><span class="srust skeyword sother">where</span>
	<span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust skeyword soperator">&lt;</span><span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'0, <span class="srust sstorage stype">i32</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust skeyword soperator">as</span> LendingIterator<span class="srust skeyword soperator">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sseparator">:</span> Debug<span class="srust spunctuation sseparator">,</span>
</span></code></pre><p>The <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span></span></code> syntax means that we must verify that <em>any</em> lifetime can be substituted in the right hand side and the trait bound must still pass. A good edge case to check here is <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code>, since we know that if that check fails the overall bound will definitely fail. So we end up with this:</p><pre class=scode><code><span class="srust ssource"><span class="srust skeyword sother">where</span>
	<span class="srust skeyword soperator">&lt;</span><span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'0, <span class="srust sstorage stype">i32</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust skeyword soperator">as</span> LendingIterator<span class="srust skeyword soperator">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'static</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sseparator">:</span> Debug<span class="srust spunctuation sseparator">,</span>
</span></code></pre><p>Or in other words, the associated item type of <code class=scode>WindowsMut</code> must implement <code class=scode>Debug</code> when fed the lifetime <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code>. Let’s hop back to the implementation of <code class=scode>LendingIterator</code> for <code class=scode>WindowsMut</code> to see if that actually holds. As a quick refresher, the relevant bit of code is here:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIterator</span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust skeyword soperator">></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span>T<span class="srust spunctuation sseparator">;</span> <span class="srust sother sconstant">WINDOW_SIZE</span><span class="srust spunctuation ssection sgroup send">]</span></span> <span class="srust skeyword sother">where</span> <span class="srust sentity sname slabel">'a</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sterminator">;</span>
	<span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Uhh…that’s a bit complex. Let’s replace the generic types with our concrete ones to simplify it.</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl">LendingIterator <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'0, <span class="srust sstorage stype">i32</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'static</span><span class="srust skeyword soperator">></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'static</span> <span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation sseparator">;</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation ssection sgroup send">]</span></span>
	<span class="srust skeyword sother">where</span>
		<span class="srust skeyword soperator">'</span><span class="srust sconstant sdecimal sinteger snumeric">0</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'static</span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>And now we can finally see what’s going wrong. As we established earlier, <code class=scode>'0</code> is the local lifetime of <code class=scode><span class="srust ssource"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span></span></code> and is therefore definitely a shorter lifetime than <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code>. This means that there is absolutely no way that the bound <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">'</span><span class="srust sconstant sdecimal sinteger snumeric">0</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'static</span></span></code> will hold, making <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&lt;</span><span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'0, <span class="srust sstorage stype">i32</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust skeyword soperator">as</span> LendingIterator<span class="srust skeyword soperator">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'static</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></code> an invalid type altogether. So of course the compiler can’t verify that it implements <code class=scode>Debug</code> — it doesn’t even exist at all! This was what the compiler was really trying to tell us earlier, even if it was a bit obtuse about it.</p><p>The ultimate conclusion of all this is that HRTBs basically can’t be used with lifetime GATs at all. <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span></span></code> just doesn’t express the right requirement — we don’t want to require the bound for <em>any</em> lifetime, we only really want to require it for lifetimes <em>shorter than <code class=scode>'0</code></em>. Ideally, we would be able to write in a <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span></span></code> clause there, so the bounds of <code class=scode>print_items</code> could become:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">print_items</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">iter</span><span class="srust spunctuation sseparator">:</span> I</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
</span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	I<span class="srust spunctuation sseparator">:</span> LendingIterator,
	<span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span> where I<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">I</span><span class="srust spunctuation saccessor">::</span></span></span><span class="srust smeta sgeneric">Item<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sseparator">:</span> Debug,
</span></span></code></pre><p>This would mean that <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> can’t be selected as the lifetime chosen for the HRTB since <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'0, <span class="srust sstorage stype">i32</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></code> is <em>definitely not</em> <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code>, so our above proof-by-contradiction would no longer work and the compiler would accept our correct code without problem.</p><p>But unfortunately it doesn’t look like we’ll be getting this feature any time soon. At the time of writing I do not know of any RFC or formal suggestion for this feature (other than <a href=https://github.com/rust-lang/rust/issues/95268>one rust-lang/rust issue</a>) so it’ll be a long time before it actually arrives on stable should we get it at all. Until then, we’re stuck with a hard limitation every time you use lifetime GATs: you can’t place trait bounds on GATs or require them to be a specific type unless the trait implementor is <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code>.</p><p>This makes real GATs practically unusable for most use cases. I’m still happy they’re being stabilized, but they likely won’t see wide adoption in APIs until this problem is solved.</p><p>So, what can we do in the meantime?</p><h2 id=dyn-trait-as-a-hkt><a href=#dyn-trait-as-a-hkt class=anchor></a>Workaround 1: <code class=scode>dyn Trait</code> as a HKT</h2><p>As first shared in <a href=https://gist.github.com/jix/42d0e4a36ace4c618a59f0ba03be5bf5>this gist</a> by <a href=https://github.com/jix>@jix</a>, one workaround is to use <code class=scode>dyn Trait</code> as a form of HKT, because <code class=scode>dyn Trait</code> accepts an HRTB in its type, <em>and</em> supports changing associated types based on the HRTB’s lifetime.</p><p>To implement the design in our code, first we modify the <code class=scode>LendingIterator</code> trait to look like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">GivesItem</span>&lt;'a> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIterator</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">?</span><span class="srust stype ssupport">Sized</span> <span class="srust skeyword soperator">+</span> <span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">GivesItem<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sterminator">;</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item as <span class="srust smeta sgeneric">GivesItem<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>The magic comes in the implementation of <code class=scode>LendingIterator</code> for specific types. For <code class=scode>WindowsMut</code> it looks like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIterator</span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span> <span class="srust skeyword soperator">=</span> dyn <span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">GivesItem<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>
		<span class="srust sstorage smodifier slifetime">'this</span>,
		Item = <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span>T<span class="srust spunctuation sseparator">;</span></span> WINDOW_SIZE],
	<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sterminator">;</span>

	<span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> ... <span class="srust spunctuation sdefinition scomment">*/</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>As you can see, the <code class=scode>Item</code> type is set to a <code class=scode>dyn Trait</code> with an HRTB, where the <code class=scode>dyn Trait</code>’s associated type depends on the input HRTB lifetime. So even though <code class=scode><span class="srust ssource"><span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span></span></code> is only a single type, it actually acts like a function from a lifetime to a type, just like a real GAT.</p><p>We can then modify the signature of <code class=scode>print_items</code> like so:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">print_items</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">iter</span><span class="srust spunctuation sseparator">:</span> I</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
</span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	I<span class="srust spunctuation sseparator">:</span> LendingIterator,
	<span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">I</span><span class="srust spunctuation saccessor">::</span></span></span>Item as <span class="srust smeta sgeneric">GivesItem<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sseparator">:</span> Debug,
</span></span></code></pre><p>And lo and behold, it works!</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation ssection sgroup send">]</span></span>
<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span>
</span></code></pre><p>However, this approach runs into some nasty limitations rather quickly. Let’s say that we have now defined a mapping operation on lending iterators:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">map</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I, F<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust svariable sparameter">iter</span><span class="srust spunctuation sseparator">:</span> I, <span class="srust svariable sparameter">mapper</span><span class="srust spunctuation sseparator">:</span> F</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Map<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I, F<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	I<span class="srust spunctuation sseparator">:</span> LendingIterator,
	F<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta sgeneric">Mapper<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, <span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">I</span><span class="srust spunctuation saccessor">::</span></span></span>Item as <span class="srust smeta sgeneric">GivesItem<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span>,
</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	Map <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span> iter<span class="srust spunctuation sseparator">,</span> mapper </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta sstruct"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">Map</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I, F<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust smeta sstruct"> </span><span class="srust smeta sstruct"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sother smember svariable">iter</span><span class="srust spunctuation sseparator">:</span> I,
	<span class="srust sother smember svariable">mapper</span><span class="srust spunctuation sseparator">:</span> F,
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I, F<span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> LendingIterator <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">Map</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I, F<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	I<span class="srust spunctuation sseparator">:</span> LendingIterator,
	F<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta sgeneric">Mapper<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, <span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">I</span><span class="srust spunctuation saccessor">::</span></span></span>Item as <span class="srust smeta sgeneric">GivesItem<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span>,
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span> <span class="srust skeyword soperator">=</span> dyn <span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">GivesItem<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>
		<span class="srust sstorage smodifier slifetime">'this</span>,
		Item = <span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>F as <span class="srust smeta sgeneric">Mapper<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span>, <span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">I</span><span class="srust spunctuation saccessor">::</span></span></span>Item as <span class="srust smeta sgeneric">GivesItem<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Output,
	<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sterminator">;</span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Item as <span class="srust smeta sgeneric">GivesItem<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
		<span class="srust svariable slanguage">self</span>.iter.<span class="srust sfunction ssupport">next</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable slanguage">self</span>.mapper</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Trait helper to allow the lifetime of a mapping function's output to depend
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> on its input. Without this, `map` on an iterator would always force lending
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> iterators to become non-lending which we don't really want.
</span><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">Mapper</span>&lt;'a, I>: FnMut(I) -> &lt;Self as Mapper&lt;'a, I>>::Output <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Output</span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, I, F, O<span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust smeta sgeneric">Mapper<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, I<span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">F</span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	F<span class="srust spunctuation sseparator">:</span> FnMut<span class="srust spunctuation sbegin ssection sgroup">(</span>I<span class="srust spunctuation ssection sgroup send">)</span> -> O,
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Output</span> <span class="srust skeyword soperator">=</span> O<span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>and then decide to use a mapped iterator instead of the normal one:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> array <span class="srust skeyword soperator">=</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> iter <span class="srust skeyword soperator">=</span> <span class="srust smeta spath">windows_mut<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">mapper</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust svariable sparameter">input</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> [<span class="srust sstorage stype">i32</span>; 2]</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust sstorage stype">i32</span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> input<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">0</span><span class="srust spunctuation ssection sgroup send">]</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust sstorage stype">let</span> mapped <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span>iter<span class="srust spunctuation sseparator">,</span> mapper</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta spath">print_items<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">Map<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, <span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span>mapped</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>This works fine, printing the desired result of <code class=scode>1</code> followed by <code class=scode>2</code>.</p><p>But if we suddenly decide that the code in <code class=scode>print_items</code> should be inlined, we’re in for a not-so-fun little surprise:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> mapped <span class="srust skeyword soperator">=</span> <span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span>iter<span class="srust spunctuation sseparator">,</span> mapper</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust skeyword scontrol">while</span> <span class="srust sstorage stype">let</span> <span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span>item</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword soperator">=</span> mapped.<span class="srust sfunction ssupport">next</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{item:?}</span><span class="srust spunctuation sdefinition send sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span></code></pre><pre class=scode><code>error[E0308]: mismatched types
  --> src/main.rs:97:35
   |
97 |     while let Some(item) = mapped.next() {
   |                                   ^^^^ one type is more general than the other
   |
   = note: expected associated type `&lt;(dyn for&lt;'this> GivesItem&lt;'this, for&lt;'this> Item = &'this mut [i32; 2]> + 'static) as GivesItem&lt;'_>>::Item`
              found associated type `&lt;(dyn for&lt;'this> GivesItem&lt;'this, for&lt;'this> Item = &'this mut [i32; 2]> + 'static) as GivesItem&lt;'this>>::Item`
</code></pre><p>To be honest, I have absolutely no idea what this error message is saying — but I’m pretty sure it’s just nonsense because the generic version works fine.</p><p>This isn’t the worst problem in the world — it’s inconvenient but it can probably always be worked around. That said, it is still possible to improve the ergonomics.</p><h2 id=hrtb-supertrait><a href=#hrtb-supertrait class=anchor></a>Workaround 2: HRTB supertrait</h2><p>Let’s try a different approach then. We’ll start again from the real GAT version, but this time with explicit lifetimes (you’ll see why in a minute):</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIterator</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust skeyword soperator">></span> <span class="srust skeyword sother">where</span> <span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sterminator">;</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span><span class="srust smeta sgeneric">Item<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>You’ll notice that all items of the trait use the <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'this</span></span></code> lifetime. So we can eliminate the use of GATs by raising that lifetime up one level, to become a generic parameter of the whole trait instead of each item on the trait.</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIterator</span>&lt;'this>
<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> This where bound is raised from the GAT
</span>where
	Self: 'this,
<span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust spunctuation sterminator">;</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span><span class="srust smeta sgeneric">Item<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>This way, <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></code> becomes an identical trait to the old <code class=scode>LendingIterator</code> trait — given a specific lifetime, we get both a <code class=scode>next</code> function and <code class=scode>Item</code> associated type.</p><p>However, there are a few problems with a trait declared this way:</p><ol><li><code class=scode><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"></span></span></code> is verbose and doesn’t allow eliding the lifetimes.</li><li>The trait bound <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></code> is long and inconvenient to spell out.</li><li>Some functions like <code class=scode>for_each</code> need <code class=scode>Self</code> to implement <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></code> in order for their signature to work. But it’s hard to express that within a trait <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">LendingIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></code> where the HRTB is not already present.</li></ol><p>To solve them we can split the trait into two, moving the parts that can have generic parameters (functions) into an outer lifetime-less subtrait and the parts that can’t have generic parameters (types) into an inner lifetimed supertrait:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIteratorLifetime</span>&lt;'this>
where
	Self: 'this,
<span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIterator</span>: for&lt;'this> LendingIteratorLifetime&lt;'this> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">Self</span> as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Now we can finally get to reimplementing <code class=scode>WindowsMut</code>:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span>, <span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIteratorLifetime</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	<span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'this</span>,
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span>T<span class="srust spunctuation sseparator">;</span> <span class="srust sother sconstant">WINDOW_SIZE</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIterator</span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">Self</span> as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
		<span class="srust skeyword scontrol">if</span> <span class="srust skeyword soperator">!</span><span class="srust svariable slanguage">self</span>.first <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
			<span class="srust svariable slanguage">self</span>.slice <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta spath">mem<span class="srust spunctuation saccessor">::</span></span>take<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable slanguage">self</span>.slice</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust skeyword soperator">..</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
		</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
		<span class="srust svariable slanguage">self</span>.first <span class="srust skeyword soperator">=</span> <span class="srust sconstant slanguage">false</span><span class="srust spunctuation sterminator">;</span>

		<span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust svariable slanguage">self</span>.slice.<span class="srust sfunction ssupport">get_mut</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">..</span><span class="srust sother sconstant">WINDOW_SIZE</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust skeyword soperator">?</span>.<span class="srust sfunction ssupport">try_into</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Let’s try it out then! Just run <code class=scode>cargo build</code> and…</p><pre class=scode><code>error[E0477]: the type `WindowsMut&lt;'a, T, WINDOW_SIZE>` does not fulfill the required lifetime
  --> src/main.rs:41:39
   |
41 | impl&lt;'a, T, const WINDOW_SIZE: usize> LendingIterator
   |                                       ^^^^^^^^^^^^^^^
</code></pre><p>Right — I should know better than to expect things to work first try at this point.</p><p>That error’s extremely unhelpful, but there is actually a legitimate explanation for what’s happening here. Once again putting on our compiler hats, one of our jobs when checking a trait implementation is to check whether the supertraits hold. In this case that means we have to satisfy this trait bound:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span></code></pre><p>Like before, a good edge case to check for with HRTB bounds is whether substituting in <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> holds. In other words, a necessary condition for the above bound to be satisfied is that this bound is also satisfied:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'static</span><span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span></code></pre><p>So let’s check that. Jumping to the implementation of <code class=scode>LendingIteratorLifetime</code> for <code class=scode>WindowsMut</code>, we see this:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span>, <span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIteratorLifetime</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	<span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'this</span>,
</span></span></code></pre><p>and substituting in <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'this</span></span></code> for <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code>:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIteratorLifetime</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'static</span><span class="srust spunctuation sdefinition sgeneric send">></span></span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	<span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'static</span>,
</span></span></code></pre><p>…ah. <code class=scode><span class="srust ssource"><span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'static</span></span></code>. That’s probably a problem.</p><p>Indeed, if we add a <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span> <span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'static</span></span></code> to the <code class=scode>LendingIterator</code> implementation it <em>does</em> compile:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIterator</span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	<span class="srust sstorage stype">Self</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'static</span>,
</span></span></code></pre><p>But that’s definitely not something we want to do — it would mean that <code class=scode>WindowsMut</code> would only work on empty slices, global variables and leaked variables.</p><p>This is a very similar problem to the one we faced before with the GAT version: ideally, we’d be able to specify a <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span></span></code> clause within the <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span></span></code> bound so that only lifetimes shorter than <code class=scode>Self</code> could be substituted in, excluding lifetimes like <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> for non-<code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> <code class=scode>Self</code>s. The signature could look something like this:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIterator</span>
where
	Self: for&lt;'this where Self: 'this> LendingIteratorLifetime&lt;'this>,
</span></span></code></pre><p>But just as before <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span></span></code> clauses in HRTBs unfortunately don’t exist yet, so it looks like this is just another dead end. What a shame.</p><h2 id=hrtb-implicit-bounds><a href=#hrtb-implicit-bounds class=anchor></a>HRTB implicit bounds</h2><blockquote><p>Having failed thoroughly in your mission to bring reliable and stable lifetime GATs to the Rust ecosystem, you quit programming altogether out of shame and vow to live out the rest of your days as a lowly potato farmer in the countryside. With nothing but a small amount savings and a dream, you move in to a run-down stone farmhouse in Scotland where you can live onwards peacefully and undisturbed.</p><p>Many years pass. You have grown accustomed to nature: you have seen plants grow, wither and die before your eyes more times than smallvec has had CVEs, and the seasons are now no more than a blur — day, night, summer, winter all morphing into one another and passing faster than the blink of an eye. You sleep deeply and peacefully every night, safe and comfortable in the knowledge that you’ll never have to deal with wall of text linker errors ever again. You have become so familiar with the pathways and routes around your home that you can walk them in your sleep. Every single nook and cranny of the place down to the most minute detail is etched deep into your brain: the position of each plant, the location of every nest, the size and shape of each pebble.</p><p>So it is no surprise that on one chilly March morning, you immediately notice the abnormal presence of a thin white object sticking out from under a bush. Drawing closer, it appears to be a piece of paper, slightly damp from absorbing the cold morning dew. You pick it up, and as you stare at the mysterious sigils printed on the page, slowly — very slowly — a vague memory begins to come back to you. That’s right, it’s “Rust”. And this “Rust” on the page appears to form a very short program:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">example</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust svariable sparameter">value</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
</span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	<span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> T<span class="srust spunctuation sseparator">:</span> Debug,
</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust ssupport smacro">eprintln!</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span>{:?}<span class="srust spunctuation sdefinition send sstring">"</span></span><span class="srust spunctuation sseparator">,</span> <span class="srust skeyword soperator">&</span>value</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust sstorage stype">let</span> array <span class="srust skeyword soperator">=</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sfunction ssupport">example</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span>array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>As you make your way back to the farmhouse, mysterious piece of paper in hand, you ponder about what it could mean. Of course, there’s no way it would compile, you know <em>that</em> much: <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span></span></code> would be able to select <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> as its lifetime, meaning <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'static</span> T</span></code> would need to implement <code class=scode>Debug</code>, which is obviously not true for the <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'array</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation sseparator">;</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span></span></code> shown (as <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'static</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'array</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation sseparator">;</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span></span></code> can’t even exist, let alone be <code class=scode>Debug</code>).</p><p>So why would someone go to the effort of printing out code that doesn’t even work — and what’s more, placing it all the way in your farm? It is this that you wonder about while you dig out your old laptop from deep inside storage. It hasn’t been touched for five years, so it’s gotten a little dusty — but you press the power button and screen bursts into colour and life, exactly as it used to do those so many years ago.</p><p>Tentatively, you open a text editor, and begin copying out the contents of that paper inside it. Now, how do I build it again? Shipment? Freight? Haul? No, it was something different…ah, cargo, that was it. Into the shell you type out the words you haven’t seen for so, so long:</p><pre class=scode><code><span class="ssource sbash sshell"><span class="smeta sfunction-call sshell"><span class="svariable sfunction sshell">cargo</span></span><span class="smeta sfunction-call sshell sarguments"> run</span>
</span></code></pre><p>You take a deep breath, and then press the enter key. The fan whirrs as the CPU starts into life. For a short moment that feels like an eon, Cargo displays “Building” — but eventually it finishes, and as it does, one line of text rolls down the screen:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span>
</span></code></pre></blockquote><p>Wait, what? Do that again.</p><blockquote><p>You take a deep breath, and then press the enter key. The fan whirrs as the CPU starts into life. For a short moment that feels like an eon, Cargo displays “Building” — but eventually it finishes, and as it does, one line of text rolls down the screen:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span>
</span></code></pre></blockquote><p>So it wasn’t just a fluke. But that makes no sense at all: by all the rules we knew, there is <em>no way</em> that code should’ve compiled. So what’s happening here?</p><p>The answer is that while <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span></span></code> does not support explicit <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span></span></code> clauses, it actually can, sometimes, have an <em>implied</em> <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span></span></code> clause — in this case, it’s <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust skeyword sother">where</span> I<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span></span></code>. But it only occurs in specific scenarios: in particular, when there is an <em>implicit bound</em> in the type or trait bound the HRTB is applied to, that implicit bound gets forwarded to the implicit <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span></span></code> clause of the HRTB.</p><p>An implicit bound is a trait bound that is present, but not stated explicitly by a colon in the generics or <code class=scode><span class="srust ssource"><span class="srust skeyword sother">where</span></span></code> clause. As you can infer from the example above, <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> T</span></code> contains an implicit bound for <code class=scode><span class="srust ssource">T<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'a</span></span></code> — this is a really simple rule to prevent nonsense types like <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'static</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'short_lifetime</span> <span class="srust sstorage stype">i32</span></span></code> (a reference that outlives borrowed contents). It’s this rule that causes <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> T</span></code> to act like it’s actually <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust skeyword sother">where</span> T<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> T</span></code>, enabling that code to run and successfully print <code class=scode><span class="srust ssource"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span></span></code>.</p><p>Implicit bounds can appear on structs too. For example, take this struct:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust svariable sannotation">derive</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">Debug</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust spunctuation ssection sgroup send">]</span></span>
<span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">Reference</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust smeta sstruct"></span><span class="srust smeta sstruct"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> T</span><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>Because <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> T</span></code> has an implicit bound of <code class=scode><span class="srust ssource">T<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'a</span></span></code>, the struct <code class=scode>Reference</code> <em>also</em> has an implicit bound of <code class=scode><span class="srust ssource">T<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'a</span></span></code>. You can prove this because this code compiles:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">example</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust svariable sparameter">value</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
</span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	<span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> where T: 'a <span class="srust spunctuation sdefinition scomment">*/</span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta sgeneric">Reference<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sseparator">:</span> Debug,
</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust ssupport smacro">dbg!</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span>Reference<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span>value</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust sstorage stype">let</span> array <span class="srust skeyword soperator">=</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sfunction ssupport">example</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span>array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>However, as soon as you try to upgrade the implicit bound to an explicit one you will notice it no longer compiles:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sannotation"><span class="srust spunctuation sdefinition sannotation">#</span><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust svariable sannotation">derive</span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup">Debug</span></span><span class="srust smeta sparameters sannotation"><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust spunctuation ssection sgroup send">]</span></span>
<span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">Reference</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust smeta sstruct"></span><span class="srust smeta sstruct"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> T</span><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">example</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust svariable sparameter">value</span><span class="srust spunctuation sseparator">:</span> T</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
</span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	<span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta sgeneric">Reference<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sseparator">:</span> Debug,
</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust ssupport smacro">dbg!</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span>Reference<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span>value</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust sstorage stype">let</span> array <span class="srust skeyword soperator">=</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sfunction ssupport">example</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span>array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><pre class=scode><code>error[E0597]: `array` does not live long enough
  --> src/main.rs:15:13
   |
15 |     example(&array);
   |     --------^^^^^^-
   |     |       |
   |     |       borrowed value does not live long enough
   |     argument requires that `array` is borrowed for `'static`
16 | }
   | - `array` dropped here while still borrowed
</code></pre><p>Implicit bounds in HRTBs are…a very weird feature of Rust. I’m still not sure whether they are intended to exist or are just an obscure side-effect of the current implementation. But either way, this is an incredibly useful feature for us. If we can somehow leverage this to apply it in our supertrait HRTB of <code class=scode>LendingIterator</code>, then we can maybe get it to actually work without the <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> bound! Thanks, mysterious piece of paper.</p><h2 id=the-better-gats><a href=#the-better-gats class=anchor></a>Workaround 3: The better GATs</h2><p>Armed with our new knowledge of implied bounds, all we have to do is get it to work in conjuction with that <code class=scode><span class="srust ssource"><span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></code> supertrait. One way to achieve this is to introduce a new dummy type parameter to <code class=scode>LendingIteratorLifetime</code>, so that HRTBs can make use of it to apply their own implicit bounds:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIteratorLifetime</span>&lt;'this, ExtraParam> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIterator</span>
where
	Self: for&lt;'this <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> where Self: 'this <span class="srust spunctuation sdefinition scomment">*/</span></span>>
		LendingIteratorLifetime&lt;'this, &'this Self>,
<span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">Self</span> as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span>, <span class="srust skeyword soperator">&</span><span class="srust sstorage stype">Self</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>This <em>works</em>, but it’s a pain to have to write out <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage stype">Self</span></span></code> every time you want to use the trait. Ergonomics can be improved slightly by using a default type parameter:</p><pre class=scode><code><span class="srust ssource"><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Give every usage of this trait an implicit `where Self: 'this` bound
</span><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIteratorLifetime</span>&lt;'this, ImplicitBounds = &'this Self> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIterator</span>
where
	Self: for&lt;'this <span class="srust sblock scomment"><span class="srust spunctuation sdefinition scomment">/*</span> where Self: 'this <span class="srust spunctuation sdefinition scomment">*/</span></span>> LendingIteratorLifetime&lt;'this>,
<span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">Self</span> as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>There is still one slight improvement we can make to reduce the chance the API is accidentally misused by setting the <code class=scode>ImplicitBounds</code> parameter to something other than <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage stype">Self</span></span></code>, and that is using a sealed type and trait. This leads to my current recommended definition for this trait:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIteratorLifetime</span>&lt;'this, ImplicitBounds: Sealed = Bounds&lt;&'this Self>> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta smodule"><span class="srust sstorage stype smodule">mod</span> <span class="srust sentity sname smodule">sealed</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">Sealed</span>: Sized <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
	<span class="srust smeta sstruct"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">Bounds</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust smeta sstruct"></span><span class="srust smeta sstruct"><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span>T</span><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
	<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> Sealed <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">Bounds</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sdefinition sgeneric send">></span></span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust skeyword sother">use</span> <span class="srust smeta spath">sealed<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>Bounds<span class="srust spunctuation sseparator">,</span> Sealed</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIterator</span>: for&lt;'this> LendingIteratorLifetime&lt;'this> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">Self</span> as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>New trait in hand, we can rewrite our type <code class=scode>WindowsMut</code> to use it:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span>, <span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIteratorLifetime</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span>T<span class="srust spunctuation sseparator">;</span> <span class="srust sother sconstant">WINDOW_SIZE</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, const WINDOW_SIZE<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIterator</span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">WindowsMut</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, T, WINDOW_SIZE<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">Self</span> as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
		<span class="srust skeyword scontrol">if</span> <span class="srust skeyword soperator">!</span><span class="srust svariable slanguage">self</span>.first <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
			<span class="srust svariable slanguage">self</span>.slice <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta spath">mem<span class="srust spunctuation saccessor">::</span></span>take<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable slanguage">self</span>.slice</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust skeyword soperator">..</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>
		</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
		<span class="srust svariable slanguage">self</span>.first <span class="srust skeyword soperator">=</span> <span class="srust sconstant slanguage">false</span><span class="srust spunctuation sterminator">;</span>

		<span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust svariable slanguage">self</span>.slice.<span class="srust sfunction ssupport">get_mut</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">..</span><span class="srust sother sconstant">WINDOW_SIZE</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust skeyword soperator">?</span>.<span class="srust sfunction ssupport">try_into</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>as well as <code class=scode>Map</code> (the <code class=scode>Mapper</code> trait is still needed):</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span>, I, F<span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">Map</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I, F<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	I<span class="srust spunctuation sseparator">:</span> LendingIterator,
	F<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta sgeneric">Mapper<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, <span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span>,
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span> <span class="srust skeyword soperator">=</span> <span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>F as <span class="srust smeta sgeneric">Mapper<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>
		<span class="srust sstorage smodifier slifetime">'this</span>,
		<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item,
	<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Output<span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I, F<span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> LendingIterator <span class="srust skeyword sother">for</span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">Map</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I, F<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	I<span class="srust spunctuation sseparator">:</span> LendingIterator,
	F<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta sgeneric">Mapper<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, <span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span>,
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">Self</span> as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
		<span class="srust svariable slanguage">self</span>.iter.<span class="srust sfunction ssupport">next</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable slanguage">self</span>.mapper</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>and unlike both real GATs and <a href=#dyn-trait-as-a-hkt>workaround 1</a>, this works with both consuming the concrete type directly <em>and</em> through the generic <code class=scode>print_items</code> function. Perfect!</p><h2 id=dyn-safety><a href=#dyn-safety class=anchor></a>Dyn safety</h2><p>The main disadvantage of workaround 3 in comparison to workaround 1 is that it is not <code class=scode>dyn</code>-safe. If you try to use it as a trait object, <code class=scode>rustc</code> helpfully tells you this:</p><pre class=scode><code>note: for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit &lt;https://doc.rust-lang.org/reference/items/traits.html#object-safety>
   --> src/main.rs:14:28
    |
14  | pub trait LendingIterator: for&lt;'this> LendingIteratorLifetime&lt;'this> {
    |           ---------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...because it uses `Self` as a type parameter
    |           |
    |           this trait cannot be made into an object...
</code></pre><p>When it says “because it uses <code class=scode>Self</code> as a type parameter” it’s actually referring to the hidden <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">Bounds<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage stype">Self</span><span class="srust spunctuation sdefinition sgeneric send">></span></span></span></code> default parameter we inserted. As a result, making <code class=scode>LendingIterator</code> <em>directly</em> work with <code class=scode>dyn</code> is simply not possible.</p><p>But that is <em>not</em> to say that dynamic dispatch is altogether impossible — all we have to do is define a helper trait for it! And as long as that helper trait uses workaround 1, it will be perfectly object-safe. This does lead to slightly worse ergnomics when using trait objects (due to that compiler bug with concrete types) but there really isn’t much we can do about that.</p><p>So let’s start by bringing back our old definition of <code class=scode>LendingIterator</code>, but this time under the name <code class=scode>ErasedLendingIterator</code>:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">LendingIteratorGats</span>&lt;'a> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta strait"><span class="srust sstorage smodifier">pub</span> <span class="srust sstorage stype strait">trait</span> <span class="srust sentity sname strait">ErasedLendingIterator</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Gats</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">?</span><span class="srust stype ssupport">Sized</span> <span class="srust skeyword soperator">+</span> <span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIteratorGats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sterminator">;</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">erased_next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Gats as <span class="srust smeta sgeneric">LendingIteratorGats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Next, we add a blanket implementation of this trait for all <code class=scode>LendingIterator</code>s:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I<span class="srust spunctuation sseparator">:</span> <span class="srust sillegal sinvalid">?</span></span></span><span class="srust smeta simpl"><span class="srust simpl sentity sname">Sized</span> + <span class="srust simpl sentity sname">LendingIterator</span>> <span class="srust simpl sentity sname">ErasedLendingIterator</span> <span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">I</span> </span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Gats</span> <span class="srust skeyword soperator">=</span> dyn <span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIteratorGats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>
		<span class="srust sstorage smodifier slifetime">'this</span>,
		Item = <span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>I as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item,
	<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sterminator">;</span>

	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">erased_next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta spath"><span class="srust sstorage stype"><span class="srust sstorage stype">Self</span><span class="srust spunctuation saccessor">::</span></span></span>Gats as <span class="srust smeta sgeneric">LendingIteratorGats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
		<span class="srust svariable slanguage">self</span>.<span class="srust sfunction ssupport">next</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Finally, we implement the regular <code class=scode>LendingIterator</code> trait on all the trait objects we own:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span>, Gats<span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIteratorLifetime</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">dyn</span> '_ + <span class="srust simpl sentity sname">ErasedLendingIterator</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Gats = Gats<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	Gats<span class="srust spunctuation sseparator">:</span> ?Sized + <span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta sgeneric">LendingIteratorGats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span>,
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Item</span> <span class="srust skeyword soperator">=</span> <span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Gats as <span class="srust smeta sgeneric">LendingIteratorGats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span></span><span class="srust smeta simpl"><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Gats<span class="srust spunctuation sdefinition sgeneric send">></span></span></span><span class="srust smeta simpl"> <span class="srust simpl sentity sname">LendingIterator</span>
	<span class="srust simpl sentity sname">for</span> <span class="srust simpl sentity sname">dyn</span> '_ + <span class="srust simpl sentity sname">ErasedLendingIterator</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Gats = Gats<span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span><span class="srust smeta simpl"><span class="srust skeyword sother">where</span>
	Gats<span class="srust spunctuation sseparator">:</span> ?Sized + <span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta sgeneric">LendingIteratorGats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span>,
</span><span class="srust smeta simpl"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">next</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">self</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage stype">Self</span> as <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sbegin sdefinition sgeneric">></span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>Item<span class="srust spunctuation sdefinition sgeneric send">></span></span></span> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
		<span class="srust svariable slanguage">self</span>.<span class="srust sfunction ssupport">erased_next</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> omitted implementations for all the permutations of auto traits. in a real
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> implementation, you'd probably use a macro to generate all 32 versions
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> (since there are 5 auto traits)
</span></span></code></pre><p>This is fairly standard boilerplate for defining an object-safe version of a non-object-safe trait, so I won’t explain it in great detail here.</p><p>Great, let’s try it out! Here, we can use it to create an iterator over either windows of size 2 or windows of size 3.</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> array <span class="srust skeyword soperator">=</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sconstant sdecimal sinteger snumeric">1</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">2</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">3</span><span class="srust spunctuation sseparator">,</span> <span class="srust sconstant sdecimal sinteger snumeric">4</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">unsize</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>const N<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">usize</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust svariable sparameter">array</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> [<span class="srust sstorage stype">i32</span>; N]</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> </span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation ssection sgroup send">]</span></span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	array
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>

<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Gats</span> <span class="srust skeyword soperator">=</span> dyn <span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIteratorGats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, Item = <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Erased</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'iter</span><span class="srust skeyword soperator">></span> <span class="srust skeyword soperator">=</span> dyn <span class="srust sstorage smodifier slifetime">'iter</span> <span class="srust skeyword soperator">+</span> <span class="srust smeta sgeneric">ErasedLendingIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Gats = Gats<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> iter<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Box<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">Erased<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword scontrol">if</span> <span class="srust sconstant slanguage">true</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust stype ssupport">Box</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust smeta spath">windows_mut<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">,</span> unsize</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span> <span class="srust skeyword scontrol">else</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust stype ssupport">Box</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust smeta spath">windows_mut<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, 3<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">,</span> unsize</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust skeyword scontrol">while</span> <span class="srust sstorage stype">let</span> <span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span>item</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust skeyword soperator">=</span> iter.<span class="srust sfunction ssupport">next</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
    <span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{item:?}</span><span class="srust spunctuation sdefinition send sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>
</span></code></pre><p>and <code class=scode>cargo build</code> it…</p><pre class=scode><code><span class="srust ssource">error<span class="srust spunctuation sseparator">:</span> implementation of `LendingIteratorLifetime` is not general enough
   <span class="srust skeyword soperator">-</span><span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> src</span><span class="srust skeyword soperator">/</span>main.rs<span class="srust spunctuation sseparator">:</span><span class="srust sconstant sdecimal sinteger snumeric">166</span><span class="srust spunctuation sseparator">:</span><span class="srust sconstant sdecimal sinteger snumeric">3</span>
    <span class="srust skeyword soperator">|</span>
<span class="srust sconstant sdecimal sinteger snumeric">166</span> <span class="srust skeyword soperator">|</span>         <span class="srust stype ssupport">Box</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust smeta spath">windows_mut<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">,</span> unsize</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
    <span class="srust skeyword soperator">|</span>         <span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span><span class="srust skeyword soperator">^</span> implementation of `LendingIteratorLifetime` is not general enough
    <span class="srust skeyword soperator">|</span>
    <span class="srust skeyword soperator">=</span> note<span class="srust spunctuation sseparator">:</span> `<span class="srust smeta sgeneric">Map<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">WindowsMut<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span>, <span class="srust sstorage stype">i32</span>, 2_usize<span class="srust spunctuation sdefinition sgeneric send">></span></span>, <span class="srust smeta sgeneric">for<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'r</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust sstorage stype sfunction">fn</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span></span><span class="srust smeta sgroup"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'r</span> <span class="srust sstorage smodifier">mut</span> [<span class="srust sstorage stype">i32</span>; 2]<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'r</span> <span class="srust sstorage smodifier">mut</span> </span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation ssection sgroup send">]</span></span> <span class="srust sillegal sinvalid">{</span></span><span class="srust smeta spath">unsize<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>2_usize<span class="srust spunctuation sdefinition sgeneric send">></span></span>}<span class="srust skeyword soperator">></span>` must implement `<span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'0<span class="srust spunctuation sdefinition sgeneric send">></span></span>`<span class="srust spunctuation sseparator">,</span> <span class="srust skeyword scontrol">for</span> any lifetime `<span class="srust skeyword soperator">'</span><span class="srust sconstant sdecimal sinteger snumeric">0</span>`<span class="srust skeyword soperator">...</span>
    <span class="srust skeyword soperator">=</span> note<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">...</span>but it actually implements `<span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'1<span class="srust spunctuation sdefinition sgeneric send">></span></span>`<span class="srust spunctuation sseparator">,</span> <span class="srust skeyword scontrol">for</span> some specific lifetime `<span class="srust skeyword soperator">'</span><span class="srust sconstant sdecimal sinteger snumeric">1</span>`
</span></code></pre><p>…ah. Another cryptic error.</p><p>I believe what’s happening here is the same ergnomics issue as faced with <a href=#dyn-trait-as-a-hkt>workaround 1</a>: There’s some compiler bug which makes this not work with concrete types.</p><p>So that means all we have to do to fix it is to move it into a generic function! And indeed this version does compile:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">box_erase</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'iter</span>, I<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust svariable sparameter">iter</span><span class="srust spunctuation sseparator">:</span> I</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> <span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> <span class="srust smeta sgeneric">Box<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">Erased<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'iter</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span>
</span></span><span class="srust smeta sfunction"><span class="srust skeyword sother">where</span>
	I<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'iter</span> + LendingIterator,
	I<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword sother">for</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, Item = <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span>,
</span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust stype ssupport">Box</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span>iter</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> iter<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Box<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">Erased<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword scontrol">if</span> <span class="srust sconstant slanguage">true</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sfunction ssupport">box_erase</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust smeta spath">windows_mut<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">,</span> unsize</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span> <span class="srust skeyword scontrol">else</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust sfunction ssupport">box_erase</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust smeta spath">windows_mut<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, 3<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">,</span> unsize</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>But we can do better than that, because generics are only <em>one</em> way to erase a value’s concrete type: you can also do it via return-position <code class=scode><span class="srust ssource"><span class="srust smeta simpl"><span class="srust sstorage stype simpl">impl</span> </span><span class="srust smeta simpl"><span class="srust simpl sentity sname">Trait</span></span></span></code>.</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">funnel_opaque</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'iter</span>, I<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust svariable sparameter">iter</span><span class="srust spunctuation sseparator">:</span> I</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
	<span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> impl <span class="srust sstorage smodifier slifetime">'iter</span> </span></span><span class="srust skeyword soperator">+</span> <span class="srust smeta sgeneric">ErasedLendingIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Gats = Gats<span class="srust spunctuation sdefinition sgeneric send">></span></span>
<span class="srust skeyword sother">where</span>
	I<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'iter</span> <span class="srust skeyword soperator">+</span> LendingIterator<span class="srust spunctuation sseparator">,</span>
	I<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, Item = <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sseparator">,</span>
<span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	iter
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>

<span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> iter<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Box<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">Erased<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword scontrol">if</span> <span class="srust sconstant slanguage">false</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust stype ssupport">Box</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">funnel_opaque</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust smeta spath">windows_mut<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">,</span> unsize</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span> <span class="srust skeyword scontrol">else</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust stype ssupport">Box</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">funnel_opaque</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust smeta spath">windows_mut<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, 3<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">,</span> unsize</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>And this also works.</p><p>If you want to, you can generalize <code class=scode>funnel_opaque</code> further so that it works with any <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust sstorage smodifier">mut</span> T</span></code> type instead of just <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation ssection sgroup send">]</span></span></span></code>:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Gats</span><span class="srust skeyword soperator">&lt;</span>T<span class="srust skeyword soperator">></span> <span class="srust skeyword soperator">=</span> dyn <span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIteratorGats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, Item = <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust sstorage smodifier">mut</span> T<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">Erased</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'iter</span><span class="srust spunctuation sseparator">,</span> T<span class="srust skeyword soperator">></span> <span class="srust skeyword soperator">=</span> dyn <span class="srust sstorage smodifier slifetime">'iter</span> <span class="srust skeyword soperator">+</span> <span class="srust smeta sgeneric">ErasedLendingIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Gats = <span class="srust smeta sgeneric">Gats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sterminator">;</span>

<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">funnel_opaque</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'iter</span>, I, T<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation sbegin ssection sparameters">(</span><span class="srust svariable sparameter">iter</span><span class="srust spunctuation sseparator">:</span> I</span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction">
	<span class="srust smeta sfunction sreturn-type"><span class="srust spunctuation sseparator">-></span> impl <span class="srust sstorage smodifier slifetime">'iter</span> </span></span><span class="srust skeyword soperator">+</span> <span class="srust smeta sgeneric">ErasedLendingIterator<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>Gats = <span class="srust smeta sgeneric">Gats<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>T<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span>
<span class="srust skeyword sother">where</span>
	T<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">?</span><span class="srust stype ssupport">Sized</span><span class="srust spunctuation sseparator">,</span>
	I<span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'iter</span> <span class="srust skeyword soperator">+</span> LendingIterator<span class="srust spunctuation sseparator">,</span>
	I<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword scontrol">for</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust skeyword soperator">></span> <span class="srust smeta sgeneric">LendingIteratorLifetime<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, Item = <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust sstorage smodifier">mut</span> T<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sseparator">,</span>
<span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	iter
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span>

<span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> iter<span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Box<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">Erased<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span>, <span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">[</span><span class="srust sstorage stype">i32</span><span class="srust spunctuation ssection sgroup send">]</span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust spunctuation sdefinition sgeneric send">></span></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword scontrol">if</span> <span class="srust sconstant slanguage">false</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust stype ssupport">Box</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">funnel_opaque</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust smeta spath">windows_mut<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, 2<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">,</span> unsize</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span> <span class="srust skeyword scontrol">else</span> <span class="srust smeta sblock"><span class="srust spunctuation sbegin ssection sblock">{</span>
	<span class="srust stype ssupport">Box</span><span class="srust smeta spath"><span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">funnel_opaque</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust sfunction ssupport">map</span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust smeta spath">windows_mut<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">_</span>, 3<span class="srust spunctuation sdefinition sgeneric send">></span></span><span class="srust smeta sgroup"><span class="srust spunctuation sbegin ssection sgroup">(</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> array</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">,</span> unsize</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>But unfortunately you can’t generalize it completely to any <code class=scode>LendingIterator</code>, because you just run into that compiler bug again.</p><h2 id=conclusion><a href=#conclusion class=anchor></a>Conclusion</h2><p>So there we have it - this technique is, to my knowledge, the best way to use lifetime GATs in Rust. Even once real GATs become stabilized, I predict it’ll likely still be useful for a long time to come, so you might want to familiarize yourself with it.</p><p class=back><a href=#>⮬ Back to top</a></p></main></body></html>