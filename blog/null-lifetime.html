<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1"name=viewport><meta content="dark light"name=color-scheme><meta content=#ffffff name=theme-color media=(prefers-color-scheme:light)><meta content=#000000 name=theme-color media=(prefers-color-scheme:dark)><meta content="Sabrina Jewson"property=og:site_name><link href=/favicon.ico rel=icon><link href=/apple-touch-icon.png rel=apple-touch-icon><link href=/common.css rel=stylesheet><title>Why the “Null” Lifetime Does Not Exist - Sabrina Jewson</title><meta content="Why the “Null” Lifetime Does Not Exist"property=og:title><meta content="This post originated from an interesting conversation had on the Rust community Discord the other day, in which a user asks:"name=description><meta content=article property=og:type><link href=post.css rel=stylesheet><link href=feed.xml rel=alternate title="Sabrina Jewson's Blog"type=application/atom+xml></head><body><header><a href=/ class=name>Sabrina Jewson</a><nav><a href=/reviews>Reviews</a> <a href=/blog/ >Blog</a></nav></header><main><h1>Why the “Null” Lifetime Does Not Exist</h1><p id=published><time datetime=2023-07-18>2023-07-18</time> (updated <time datetime=2023-07-22>2023-07-22</time>)</p><nav><ul><li><a href=#self-referential-types>An Overlong Interlude Where I Am Increasingly Pedantic About Self-Referential Types</a></li><li><a href=#always-a-shorter-lifetime>Always A Shorter Lifetime</a></li></ul></nav><p>This post originated from an interesting conversation had <a href=https://discord.com/channels/273534239310479360/818964227783262209/1130515943756406874>on the Rust community Discord</a> the other day, in which a user asks:</p><blockquote><p>Does <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> have an opposite? Zero lifetime that’s shorter than anything?</p></blockquote><p>Details of the question are not relevant, but intuitively the question does make sense. After all, Rust already has <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code>, representing a lifetime that is longer than or equal to all other lifetimes — so why wouldn’t there be a counterpart, maybe called <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'empty</span></span></code> or <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'null</span></span></code>, that is shorter than every other lifetime? To the type theorists out there, if <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> is our bottom type (as it can become any lifetime), wouldn’t there also hypothetically be some top type that any lifetime can become?</p><p>The short answer is “not in any way that allows you to construct a value with the lifetime”. Rust’s type system, as this post will show, is designed with the assumption that given a valid lifetime, you can always make a shorter one, so any hypothetical <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'null</span></span></code> lifetime would have to be non-constructible in the first place.</p><p>But why is that? Well, that takes a bit of explaining, but first I’d like to take a bit of a detour into the world of self-referential types…</p><h2 id=self-referential-types><a href=#self-referential-types class=anchor></a>An Overlong Interlude Where I Am Increasingly Pedantic About Self-Referential Types</h2><p>(This is going somewhere, I promise.)</p><p>You may often hear it be said that Rust does not support self-referential types. This is typically in response to a beginner attempting code like the following and thoroughly confusing themselves:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust sentity sname sstruct">OhNo</span> </span><span class="srust smeta sstruct"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sother smember svariable">base_string</span><span class="srust spunctuation sseparator">:</span> String,
	<span class="srust sother smember svariable">parts</span><span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Vec<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">&</span>'<span class="srust sillegal sinvalid">?</span></span>?? <span class="srust sstorage stype">str</span>>,
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Where <code class=scode>parts</code> is supposed to borrow from <code class=scode>base_string</code>. The beginner of course expects this to be possible but has no clue what lifetime to write in there.</p><p>Inevitably, you, the seasoned Rustacean, will put on a grave expression and slowly shake your head in frank resignation. Then, bearing the bad news like a parent informing their child of the truth about Santa Claus, you say:</p><blockquote><p>Rust does not support self-referential types.</p></blockquote><p>And the beginner’s dreams are crushed, for no matter how much they may argue against it, they will eventually have to accept the tragic truth such an abstraction is simply not possible.</p><p>But we’re programmers here, and we like things to be precise. And if this interaction should occur in any technical space, it is quite expected that some other user be rather pleased with themselves by chiming in: But what about <code class=scode>async</code>?</p><p>Well, they’re not <em>wrong</em>. So what about it?</p><p>If you’ve ever worked with <code class=scode>async</code> before, you will know that futures declared with <code class=scode>async</code> blocks have the ability to borrow values across <code class=scode>.await</code> points. For example:</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">let</span> future <span class="srust skeyword soperator">=</span> async <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sstorage stype">let</span> data <span class="srust skeyword soperator">=</span> <span class="srust sconstant sdecimal sinteger snumeric">5</span><span class="srust spunctuation sterminator">;</span>
	<span class="srust sstorage stype">let</span> r <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span>data<span class="srust spunctuation sterminator">;</span>
	<span class="srust sfunction ssupport">something_else</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.await<span class="srust spunctuation sterminator">;</span> <span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Point A
</span>	<span class="srust ssupport smacro">println!</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust sstring sdouble squoted"><span class="srust spunctuation sbegin sdefinition sstring">"</span><span class="srust sother sconstant splaceholder">{r}</span><span class="srust spunctuation send sdefinition sstring">"</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>The above future, once it suspends for the first time at point A, has to store all of the data required for resumation in its type. This means that we have to store both <code class=scode>data</code> and <code class=scode>r</code> in the future — <code class=scode>r</code> needs to be kept because we directly access it, and <code class=scode>data</code> needs to be kept since otherwise <code class=scode>r</code>’s reference would dangle into thin air. But <code class=scode>r</code> also needs to reference <code class=scode>data</code>, which means one part of the type needs to reference another — meeting exactly the definition of a self-referential type!</p><p>Okay then, you say, let’s refine the statement. <code class=scode>async</code> blocks can indeed be self-referential, but that’s not particularly useful because we can’t extract any data from them beyond the very limited <code class=scode>Future</code> interface. So we restrict our claim:</p><blockquote><p>Rust does not support self-referential <em>data structures</em>.</p></blockquote><p>This is better but still not quite true, because you can simply make a <code class=scode><span class="srust ssource"><span class="srust sstorage stype">static</span></span></code> item that depends on itself:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust sentity sname sstruct">SelfRef</span> </span><span class="srust smeta sstruct"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sother smember svariable">this</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'static</span> <span class="srust sstorage stype">Self</span>,
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust sstorage stype">static</span> <span class="srust sother sconstant">SELF_REF</span><span class="srust spunctuation sseparator">:</span> SelfRef <span class="srust skeyword soperator">=</span> SelfRef <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> this<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sother sconstant">SELF_REF</span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>Well that’s just being pedantic now. But fine, let’s adjust the claim:</p><blockquote><p>Rust does not support <em>non-static</em> self-referential data structures.</p></blockquote><p>Except, with a little interior mutability trickery with <code class=scode>Cell</code> and <code class=scode>Option</code> to get around the acyclic nature of runtime execution, this same trick <em>also</em> works on the stack:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">SelfRef</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></span><span class="srust smeta sstruct"> </span><span class="srust smeta sstruct"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sother smember svariable">this</span><span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">Cell<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust smeta sgeneric">Option<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage stype">Self</span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust spunctuation send sdefinition sgeneric">></span></span>,
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">main</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sstorage stype">let</span> self_ref <span class="srust skeyword soperator">=</span> SelfRef <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
		this<span class="srust spunctuation sseparator">:</span> <span class="srust smeta spath">Cell<span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">None</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sseparator">,</span>
	</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
	self_ref.this.<span class="srust sfunction ssupport">set</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span>self_ref</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust skeyword sother">use</span> <span class="srust smeta spath">std<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta spath">cell<span class="srust spunctuation saccessor">::</span></span>Cell<span class="srust spunctuation sterminator">;</span>
</span></code></pre><p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6fb49accec79ec9903e7753c8912159d">Try it yourself</a> — although it might be surprising, this compiles just fine, and does indeed result in a <code class=scode><span class="srust ssource"><span class="srust sstorage stype sstruct">struct</span></span></code> that technically references itself.</p><blockquote><p>Edit (2023-07-22): After this blog post was pubished, <a href=https://github.com/danielhenrymantilla>Daniel Henry-Mantilla</a> helpfully pointed out that you don’t even need interior mutability to make a stack self-referential struct like this, so long as you’re willing to sacrifice having a <em>literal</em> self-reference (<code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage stype">Self</span></span></code>) for a reference to an earlier field. Specifically, the following code just works:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sstruct"><span class="srust sstorage stype sstruct">struct</span> </span><span class="srust smeta sstruct"><span class="srust smeta sgeneric"><span class="srust sentity sname sstruct">SelfRef</span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'this</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></span><span class="srust smeta sstruct"> </span><span class="srust smeta sstruct"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sother smember svariable">a</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage stype">i32</span>,
	<span class="srust sother smember svariable">b</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'this</span> <span class="srust sstorage stype">i32</span>,
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">main</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> self_ref <span class="srust skeyword soperator">=</span> SelfRef <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> a<span class="srust spunctuation sseparator">:</span> <span class="srust sconstant sdecimal sinteger snumeric">37</span><span class="srust spunctuation sseparator">,</span> b<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sconstant sdecimal sinteger snumeric">0</span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
	self_ref.b <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span>self_ref.a<span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>The resulting <code class=scode><span class="srust ssource"><span class="srust sstorage stype sstruct">struct</span></span></code> exhibits the same behaviour we talk about later in this section, but it’s worth putting in this example as a more “pure” demonstration of the same effect. Thanks, Yandros!</p></blockquote><p>So, did we do it? Have we solved the years-long problem of self-referential types?</p><p>Well, of course not, because this approach comes with one huge problem that is a deal-breaker for almost all real-life situations: the resulting value cannot be moved or uniquely borrowed for the rest of its lifetime. Even if we do something as trivial and innocuous as dropping it, we start to see the issue.</p><pre class=scode><code><span class="ssource sdiff">struct SelfRef&lt;'this> {
	this: Cell&lt;Option&lt;&'this Self>>,
}

fn main() {
	let self_ref = SelfRef {
		this: Cell::new(None),
	};
	self_ref.this.set(Some(&self_ref));
<span class="sdiff sinserted smarkup"><span class="spunctuation sdefinition sdiff sinserted">+</span>	drop(self_ref);
</span>}

use std::cell::Cell;
</span></code></pre><pre class=scode><code>error[E0505]: cannot move out of `self_ref` because it is borrowed
  --> src/main.rs:10:10
   |
6  |     let self_ref = SelfRef {
   |         -------- binding `self_ref` declared here
...
9  |     self_ref.this.set(Some(&self_ref));
   |                            --------- borrow of `self_ref` occurs here
10 |     drop(self_ref);
   |          ^^^^^^^^
   |          |
   |          move out of `self_ref` occurs here
   |          borrow later used here

For more information about this error, try `rustc --explain E0505`.
</code></pre><p>And with unique borrowing we get a similar error:</p><pre class=scode><code><span class="ssource sdiff"><span class="sdiff smarkup sdeleted"><span class="spunctuation sdefinition sdiff sdeleted">-</span>	let self_ref = SelfRef {
</span><span class="sdiff sinserted smarkup"><span class="spunctuation sdefinition sdiff sinserted">+</span>	let self_ref = SelfRef {
</span>		this: Cell::new(None),
	};
<span class="sdiff smarkup sdeleted"><span class="spunctuation sdefinition sdiff sdeleted">-</span>	drop(self_ref);
</span><span class="sdiff sinserted smarkup"><span class="spunctuation sdefinition sdiff sinserted">+</span>	&mut self_ref.this;
</span></span></code></pre><pre class=scode><code>error[E0502]: cannot borrow `self_ref.this` as mutable because it is also borrowed as immutable
  --> src/main.rs:10:5
   |
9  |     self_ref.this.set(Some(&self_ref));
   |                            --------- immutable borrow occurs here
10 |     &mut self_ref.this;
   |     ^^^^^^^^^^^^^^^^^^
   |     |
   |     mutable borrow occurs here
   |     immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
</code></pre><p>Of course, this makes perfect sense. If we <em>were</em> allowed to uniquely borrow the <code class=scode>self_ref</code> value we could trivially use that to produce a <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span></span></code> and <code class=scode>&</code> to the same location, which is a textbook case of UB!</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> self_ref <span class="srust skeyword soperator">=</span> SelfRef <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> this<span class="srust spunctuation sseparator">:</span> <span class="srust smeta spath">Cell<span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">None</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
self_ref.this.<span class="srust sfunction ssupport">set</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span>self_ref</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> reference_1<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword soperator">=</span> self_ref.this.<span class="srust sfunction ssupport">get</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> reference_2<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> self_ref<span class="srust spunctuation sterminator">;</span>
<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Oops, UB!
</span></span></code></pre><p>These examples are quite abstract, but they show that you are barred from doing basically anything useful with the value, including returning it from functions or setting any of its fields without interior mutability. Well what did I expect, we just can’t have nice things.</p><p>At least we can improve our claim:</p><blockquote><p>Rust does not support <em>movable</em> self-referential data structures.</p></blockquote><p>Surely we’re done now? Well, for the purposes of the main point of the post we are, but since I’ve started this game I feel only obliged to indulge in this pedantry to its natural terminus. So yes, let’s continue…</p><p>Our next counterexample is that C supports movable self-referential data structures. So if Rust can’t do this, does this mean Rust is inherently less powerful than C? Well no, of course not, we were just only considering <em>safe</em> code up until now. You can do anything that C can with a little <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier">unsafe</span></span></code>, so let’s add that qualifier:</p><blockquote><p>Rust does not support <em>safe</em> movable self-referential data structures.</p></blockquote><p>But then we can’t ignore one of Rust’s most powerful features, the wrapping of <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier">unsafe</span></span></code> code with safe code. That is to say, one can create <em>safe abstractions</em> over what the C code would do to enable this kind of thing with safe code, through dependencies that use <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier">unsafe</span></span></code>.</p><p>As it turns out, this kind of thing is easier said than done. The original attempts at these, <code class=scode>owning_ref</code> and <code class=scode>rental</code>, are now both unsound and unmaintained; <a href=https://docs.rs/yoke><code class=scode>yoke</code></a> is also unsound in two separate ways (<a href=https://github.com/unicode-org/icu4x/issues/2095>1</a>, <a href=https://github.com/unicode-org/icu4x/issues/3696>2</a>; although neither are as of today considered exploitable) and only <a href=https://docs.rs/ouroboros><code class=scode>ouroboros</code></a> has managed to fix all the issues. But it is at least <em>possible</em>, so we can arrive at our final (really final this time, I promise) <em>true</em> statement:</p><blockquote><p>Rust does not natively support safe movable self-referential data structures.</p></blockquote><p>Well isn’t that a mouthful?</p><h2 id=always-a-shorter-lifetime><a href=#always-a-shorter-lifetime class=anchor></a>Always A Shorter Lifetime</h2><p>Let’s go back to the code example from before, where Rust prevented us from causing UB with our stack-based self-referential type.</p><pre class=scode><code><span class="srust ssource"><span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> self_ref <span class="srust skeyword soperator">=</span> SelfRef <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> this<span class="srust spunctuation sseparator">:</span> <span class="srust smeta spath">Cell<span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">None</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
self_ref.this.<span class="srust sfunction ssupport">set</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span>self_ref</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> reference_1<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword soperator">=</span> self_ref.this.<span class="srust sfunction ssupport">get</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> reference_2<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> self_ref<span class="srust spunctuation sterminator">;</span>
<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span>                                  ^^^^^^^^^^^^^ Compiler error!
</span></span></code></pre><p>This is <em>weird</em>, isn’t it? Because suppose we delete the second line — then it all compiles just fine, that’s just basic Rust borrowing rules. So what is up with that line? How can one usage of a value, involving only that value, get it into this weird twilight state where you can normally borrow but not uniquely borrow or move no matter what you do?</p><p>We know that calling any normal function on this value would <em>not</em> put it in that twilight state:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">uwu</span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">_</span>: <span class="srust skeyword soperator">&</span><span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> self_ref <span class="srust skeyword soperator">=</span> SelfRef <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> this<span class="srust spunctuation sseparator">:</span> <span class="srust smeta spath">Cell<span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">None</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sfunction ssupport">uwu</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span>self_ref</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> reference_1<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword soperator">=</span> self_ref.this.<span class="srust sfunction ssupport">get</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> reference_2<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> self_ref<span class="srust spunctuation sterminator">;</span> <span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> Compiles just fine!
</span></span></code></pre><p>So this might lead you to believe that this is some special case in the Rust compiler, that it detected we were building a self-referential type and intervened personally to protect us. But one of the beauties of the borrow checker is that’s it’s <em>not</em>, and we can show that if we first desugar the lifetimes of <code class=scode>uwu</code>, and then try to actually construct the self-referential type within it:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">uwu</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span>, <span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self_ref</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	self_ref.this.<span class="srust sfunction ssupport">set</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span>self_ref</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><pre class=scode><code>error: lifetime may not live long enough
 --> src/main.rs:4:2
  |
3 | fn uwu&lt;'a, 'b>(self_ref: &'a SelfRef&lt;'b>) {
  |        --  -- lifetime `'b` defined here
  |        |
  |        lifetime `'a` defined here
4 |     self_ref.this.set(Some(&self_ref));
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'a` must outlive `'b`
  |
  = help: consider adding the following bound: `'a: 'b`
</code></pre><p>The fact than an error occurred at all first tells us that there is some material difference between using our magic line we had and calling the <code class=scode>uwu</code> function as we’ve currrently defined it. The clue to this difference can be found in the compiler help message:</p><blockquote><p>consider adding the following bound: <code class=scode>'a: 'b</code></p></blockquote><p>So we can do that, and recompile:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">uwu</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'b</span>, <span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust svariable sparameter">self_ref</span><span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	self_ref.this.<span class="srust sfunction ssupport">set</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span>self_ref</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>

<span class="srust sstorage stype">let</span> <span class="srust sstorage smodifier">mut</span> self_ref <span class="srust skeyword soperator">=</span> SelfRef <span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span> this<span class="srust spunctuation sseparator">:</span> <span class="srust smeta spath">Cell<span class="srust spunctuation saccessor">::</span></span>new<span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">None</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span> </span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sfunction ssupport">uwu</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span>self_ref</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> reference_1<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword soperator">=</span> self_ref.this.<span class="srust sfunction ssupport">get</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span>.<span class="srust sfunction ssupport">unwrap</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust sstorage stype">let</span> reference_2<span class="srust spunctuation sseparator">:</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span>'<span class="srust skeyword soperator">_</span><span class="srust spunctuation send sdefinition sgeneric">></span></span> <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier">mut</span> self_ref<span class="srust spunctuation sterminator">;</span>
<span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span>                                  ^^^^^^^^^^^^^ error: cannot borrow `self_ref` as mutable
</span><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span>                                                because it is also borrowed as immutable
</span></span></code></pre><p>The same error as before! This means we’ve perfectly been able to extract the underlying “borrowing behaviour” behind the line <code class=scode><span class="srust ssource">self_ref.this.<span class="srust sfunction ssupport">set</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust stype ssupport">Some</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust skeyword soperator">&</span>self_ref</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span></span></code> into a function, which gives us clues as to what’s really going on here. Since we now have the right signature, we can even delete the body of <code class=scode>uwu</code> and observe that the error remains the same:</p><pre class=scode><code><span class="srust ssource"><span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">uwu</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'a</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'b</span>, <span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust skeyword soperator">_</span>: <span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span></span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
</span></code></pre><p>Recall that <code class=scode>:</code> in lifetimes means “outlives” or “lives at least as long as”. Therefore, the generic parameter section <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&lt;</span><span class="srust sentity sname slabel">'a</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation sseparator">,</span> <span class="srust sstorage smodifier slifetime">'b</span><span class="srust skeyword soperator">></span></span></code> of <code class=scode>uwu</code> tells us that it operates on the lifetimes</p><ul><li><code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'a</span></span></code>, which is the same length or longer than, <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'b</span></span></code>;</li><li>and <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'b</span></span></code>, which can be any lifetime.</li></ul><p>You can also use pure logic to reach the conclusion that a function accepting <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code> where <code class=scode><span class="srust ssource"><span class="srust sentity sname slabel">'a</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'b</span></span></code> is enough to construct a self-referential type, and thus is also enough to prevent any future moves or unique borrows: the reference type held inside the <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code> is a <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'b</span> <span class="srust sstorage stype">Self</span></span></code>, but <code class=scode><span class="srust ssource"><span class="srust sstorage stype">Self</span></span></code> in this context is <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code>, so therefore procuring a <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'b</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code> is sufficient to fill that field in. If we then have some <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code> where <code class=scode><span class="srust ssource"><span class="srust sentity sname slabel">'a</span><span class="srust spunctuation sseparator">:</span> <span class="srust sstorage smodifier slifetime">'b</span></span></code>, as it’s always valid to treat objects as living shorter then they actually do, it can be implicitly converted into the <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'b</span> <span class="srust smeta sgeneric">SelfRef<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code> as desired.</p><p>So what was all this about? Well really, it was just a long and roundabout way to demonstrate to you a theorem, in the mathematical sense, that holds in Rust:</p><blockquote><p>When you have some type with an invariant lifetime parameter <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">T<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code> and you borrow it with the lifetime <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'a</span></span></code> such that <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'a</span></span></code> outlives <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'b</span></span></code> (producing <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'a</span> <span class="srust smeta sgeneric">T<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code>), one is prevented from moving the value thereafter.</p></blockquote><p>(you might notice the presence of the qualifier “invariant” there; this is another thing I won’t go into because it’s not that relevant right now, but it is necessary for the theorem to hold).</p><p>We can then take the <a href=https://en.wikipedia.org/wiki/Contraposition>contrapositive</a> of this theorem, giving us the corollary:</p><blockquote><p>If one is able to move some type with an invariant lifetime parameter <code class=scode><span class="srust ssource"><span class="srust smeta sgeneric">T<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span></code> after borrowing it, then the lifetime which it was borrowed for is strictly shorter than <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'b</span></span></code> (as if it outlived <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'b</span></span></code>, one would not have been able to move it).</p></blockquote><p>You might be able to see where this is going now. Take the below code, which compiles:</p><pre class=scode><code><span class="srust ssource"><span class="srust scomment sdouble-slash sline"><span class="srust spunctuation sdefinition scomment">//</span> `Cell` is used to make T invariant in `'b`
</span><span class="srust sstorage stype stype">type</span> <span class="srust stype sentity sname">T</span><span class="srust skeyword soperator">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust skeyword soperator">></span> <span class="srust skeyword soperator">=</span> <span class="srust smeta sgeneric">Cell<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'b</span> <span class="srust spunctuation ssection sgroup sbegin">(</span><span class="srust spunctuation ssection sgroup send">)</span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust spunctuation sterminator">;</span>
<span class="srust smeta sfunction"><span class="srust smeta sfunction"><span class="srust sstorage stype sfunction">fn</span> </span><span class="srust sfunction sentity sname">owo</span></span><span class="srust smeta sgeneric"><span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection sbegin sparameters">(</span><span class="srust sstorage smodifier">mut</span> <span class="srust svariable sparameter">value</span><span class="srust spunctuation sseparator">:</span> <span class="srust smeta sgeneric">T<span class="srust spunctuation sbegin sdefinition sgeneric">&lt;</span><span class="srust sstorage smodifier slifetime">'b</span><span class="srust spunctuation send sdefinition sgeneric">></span></span></span><span class="srust smeta sfunction"><span class="srust smeta sfunction sparameters"><span class="srust spunctuation ssection send sparameters">)</span></span></span></span><span class="srust smeta sfunction"> </span><span class="srust smeta sfunction"><span class="srust smeta sblock"><span class="srust spunctuation ssection sbegin sblock">{</span>
	<span class="srust sstorage stype">let</span> reference <span class="srust skeyword soperator">=</span> <span class="srust skeyword soperator">&</span>value<span class="srust spunctuation sterminator">;</span>
	<span class="srust sfunction ssupport">drop</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup sbegin">(</span>value</span><span class="srust smeta sgroup"><span class="srust spunctuation ssection sgroup send">)</span></span><span class="srust spunctuation sterminator">;</span>
</span><span class="srust smeta sblock"><span class="srust spunctuation ssection send sblock">}</span></span></span>
<span class="srust skeyword sother">use</span> <span class="srust smeta spath">std<span class="srust spunctuation saccessor">::</span></span><span class="srust smeta spath">cell<span class="srust spunctuation saccessor">::</span></span>Cell<span class="srust spunctuation sterminator">;</span>
</span></code></pre><p>Here we have a function <code class=scode>owo</code>, accepting some <code class=scode>T&lt;'b></code>, borrowing it, and then moving it. This satisfies all the conditions to apply the theorem above, which tells us that the duration <code class=scode>reference</code> borrowed <code class=scode>value</code> for <strong>must</strong> be a lifetime that is strictly shorter than <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'b</span></span></code>.</p><p>But as <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'b</span></span></code> was a lifetime parameter to the function <code class=scode>owo</code>, we know that it could have been <em>any</em> lifetime — it’s not constrained in any way. This gives the final result for this section:</p><blockquote><p>Given any lifetime parameter <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'b</span></span></code>, it must be possible to construct a reference whose lifetime is required to live strictly shorter than <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'b</span></span></code> in order for Rust to be sound.</p></blockquote><p>Or, in other words,</p><blockquote><p>There is always a shorter lifetime.</p></blockquote><p>And this is the reason why the <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'null</span></span></code> lifetime doesn’t exist, at least in its naïve form. Because if it did exist, and if you could pass it to functions, those functions could always use the trick outlined above to construct a lifetime that must be shorter. This leaves us with only two possibilities:</p><ol><li><code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'null</span></span></code> is not actually shorter than every other lifetime, defeating its purpose;</li><li>Rust is unsound.</li></ol><p>Of course, this doesn’t not rule out a hypothetical “opposite of <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code>” existing entirely; merely, it proves that it must not be allowed to actually construct a variable with this lifetime. <a href=https://internals.rust-lang.org/t/opposite-of-static/5128>dtolnay’s 2017 proposal for the <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'void</span></span></code> lifetime</a> (which to my knowledge was unfortunately never pursued after that initial thread) is an example of the way in which <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> <em>could</em> have an opposite: it can be useful in traits as he shows, but it can never actually be constructed because it’s so short that any value containing a <code class=scode><span class="srust ssource"><span class="srust skeyword soperator">&</span><span class="srust sstorage smodifier slifetime">'void</span></span></code> would live longer than <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'void</span></span></code>, and thus would be disallowed.</p><p>This is quite counterintuitive, as after all if one can never construct a <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'static</span></span></code> reference to a stack value, surely one would always be able to construct a <code class=scode><span class="srust ssource"><span class="srust sstorage smodifier slifetime">'void</span></span></code> reference to a stack value — but as you’ve seen, it’s the only way for Rust’s borrow checker to still be sound.</p><p class=back><a href=#>⮬ Back to top</a></p></main></body></html>